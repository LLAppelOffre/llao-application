import {
  E as E3,
  F,
  j as j2,
  q as q2
} from "./chunk-DP6D7EXL.js";
import {
  V as V2,
  W,
  Y,
  hn as hn2,
  j,
  q
} from "./chunk-KLR4ML3O.js";
import {
  $r,
  AnimatedObject,
  Ct,
  Dr,
  E,
  E2,
  Et,
  FluidValue,
  Fr,
  It,
  L,
  M,
  Mn,
  Pt,
  Rn,
  Rt,
  T,
  V,
  Ye,
  addFluidObserver,
  area_default,
  callFluidObservers,
  cn,
  colors2,
  createHost,
  createStringInterpolator2,
  each,
  eachProp,
  getFluidValue,
  globals_exports,
  hasFluidValue,
  hn,
  hr,
  is,
  kn,
  line_default,
  pn,
  removeFluidObserver,
  require_toString,
  toArray,
  useSpring,
  w2 as w,
  wn,
  z
} from "./chunk-FQLOU77L.js";
import {
  require_jsx_runtime
} from "./chunk-OT5EQO2H.js";
import {
  require_react_dom
} from "./chunk-WRD5HZVH.js";
import {
  require_react
} from "./chunk-OU5AQDZK.js";
import {
  __commonJS,
  __toESM
} from "./chunk-EWTE5DHJ.js";

// node_modules/lodash/uniqueId.js
var require_uniqueId = __commonJS({
  "node_modules/lodash/uniqueId.js"(exports, module) {
    var toString = require_toString();
    var idCounter = 0;
    function uniqueId(prefix) {
      var id = ++idCounter;
      return toString(prefix) + id;
    }
    module.exports = uniqueId;
  }
});

// node_modules/@nivo/line/dist/nivo-line.mjs
var import_react = __toESM(require_react(), 1);
var import_uniqueId = __toESM(require_uniqueId(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);

// node_modules/@nivo/line/node_modules/@react-spring/web/dist/react-spring_web.modern.mjs
var import_react_dom = __toESM(require_react_dom(), 1);
var isCustomPropRE = /^--/;
function dangerousStyleValue(name, value) {
  if (value == null || typeof value === "boolean" || value === "") return "";
  if (typeof value === "number" && value !== 0 && !isCustomPropRE.test(name) && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]))
    return value + "px";
  return ("" + value).trim();
}
var attributeCache = {};
function applyAnimatedValues(instance, props) {
  if (!instance.nodeType || !instance.setAttribute) {
    return false;
  }
  const isFilterElement = instance.nodeName === "filter" || instance.parentNode && instance.parentNode.nodeName === "filter";
  const {
    className,
    style,
    children,
    scrollTop,
    scrollLeft,
    viewBox,
    ...attributes
  } = props;
  const values = Object.values(attributes);
  const names = Object.keys(attributes).map(
    (name) => isFilterElement || instance.hasAttribute(name) ? name : attributeCache[name] || (attributeCache[name] = name.replace(
      /([A-Z])/g,
      // Attributes are written in dash case
      (n2) => "-" + n2.toLowerCase()
    ))
  );
  if (children !== void 0) {
    instance.textContent = children;
  }
  for (const name in style) {
    if (style.hasOwnProperty(name)) {
      const value = dangerousStyleValue(name, style[name]);
      if (isCustomPropRE.test(name)) {
        instance.style.setProperty(name, value);
      } else {
        instance.style[name] = value;
      }
    }
  }
  names.forEach((name, i2) => {
    instance.setAttribute(name, values[i2]);
  });
  if (className !== void 0) {
    instance.className = className;
  }
  if (scrollTop !== void 0) {
    instance.scrollTop = scrollTop;
  }
  if (scrollLeft !== void 0) {
    instance.scrollLeft = scrollLeft;
  }
  if (viewBox !== void 0) {
    instance.setAttribute("viewBox", viewBox);
  }
}
var isUnitlessNumber = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  // SVG-related properties
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
};
var prefixKey = (prefix, key) => prefix + key.charAt(0).toUpperCase() + key.substring(1);
var prefixes = ["Webkit", "Ms", "Moz", "O"];
isUnitlessNumber = Object.keys(isUnitlessNumber).reduce((acc, prop) => {
  prefixes.forEach((prefix) => acc[prefixKey(prefix, prop)] = acc[prop]);
  return acc;
}, isUnitlessNumber);
var domTransforms = /^(matrix|translate|scale|rotate|skew)/;
var pxTransforms = /^(translate)/;
var degTransforms = /^(rotate|skew)/;
var addUnit = (value, unit) => is.num(value) && value !== 0 ? value + unit : value;
var isValueIdentity = (value, id) => is.arr(value) ? value.every((v) => isValueIdentity(v, id)) : is.num(value) ? value === id : parseFloat(value) === id;
var AnimatedStyle = class extends AnimatedObject {
  constructor({ x, y, z: z2, ...style }) {
    const inputs = [];
    const transforms = [];
    if (x || y || z2) {
      inputs.push([x || 0, y || 0, z2 || 0]);
      transforms.push((xyz) => [
        `translate3d(${xyz.map((v) => addUnit(v, "px")).join(",")})`,
        // prettier-ignore
        isValueIdentity(xyz, 0)
      ]);
    }
    eachProp(style, (value, key) => {
      if (key === "transform") {
        inputs.push([value || ""]);
        transforms.push((transform) => [transform, transform === ""]);
      } else if (domTransforms.test(key)) {
        delete style[key];
        if (is.und(value)) return;
        const unit = pxTransforms.test(key) ? "px" : degTransforms.test(key) ? "deg" : "";
        inputs.push(toArray(value));
        transforms.push(
          key === "rotate3d" ? ([x2, y2, z22, deg]) => [
            `rotate3d(${x2},${y2},${z22},${addUnit(deg, unit)})`,
            isValueIdentity(deg, 0)
          ] : (input) => [
            `${key}(${input.map((v) => addUnit(v, unit)).join(",")})`,
            isValueIdentity(input, key.startsWith("scale") ? 1 : 0)
          ]
        );
      }
    });
    if (inputs.length) {
      style.transform = new FluidTransform(inputs, transforms);
    }
    super(style);
  }
};
var FluidTransform = class extends FluidValue {
  constructor(inputs, transforms) {
    super();
    this.inputs = inputs;
    this.transforms = transforms;
    this._value = null;
  }
  get() {
    return this._value || (this._value = this._get());
  }
  _get() {
    let transform = "";
    let identity = true;
    each(this.inputs, (input, i2) => {
      const arg1 = getFluidValue(input[0]);
      const [t2, id] = this.transforms[i2](
        is.arr(arg1) ? arg1 : input.map(getFluidValue)
      );
      transform += " " + t2;
      identity = identity && id;
    });
    return identity ? "none" : transform;
  }
  // Start observing our inputs once we have an observer.
  observerAdded(count) {
    if (count == 1)
      each(
        this.inputs,
        (input) => each(
          input,
          (value) => hasFluidValue(value) && addFluidObserver(value, this)
        )
      );
  }
  // Stop observing our inputs once we have no observers.
  observerRemoved(count) {
    if (count == 0)
      each(
        this.inputs,
        (input) => each(
          input,
          (value) => hasFluidValue(value) && removeFluidObserver(value, this)
        )
      );
  }
  eventObserved(event) {
    if (event.type == "change") {
      this._value = null;
    }
    callFluidObservers(this, event);
  }
};
var primitives = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
];
globals_exports.assign({
  batchedUpdates: import_react_dom.unstable_batchedUpdates,
  createStringInterpolator: createStringInterpolator2,
  colors: colors2
});
var host = createHost(primitives, {
  applyAnimatedValues,
  createAnimatedStyle: (style) => new AnimatedStyle(style),
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getComponentProps: ({ scrollTop, scrollLeft, ...props }) => props
});
var animated = host.animated;

// node_modules/@nivo/line/dist/nivo-line.mjs
function $() {
  return $ = Object.assign ? Object.assign.bind() : function(e2) {
    for (var o2 = 1; o2 < arguments.length; o2++) {
      var i2 = arguments[o2];
      for (var n2 in i2) ({}).hasOwnProperty.call(i2, n2) && (e2[n2] = i2[n2]);
    }
    return e2;
  }, $.apply(null, arguments);
}
function _(e2, o2) {
  if (null == e2) return {};
  var i2 = {};
  for (var n2 in e2) if ({}.hasOwnProperty.call(e2, n2)) {
    if (-1 !== o2.indexOf(n2)) continue;
    i2[n2] = e2[n2];
  }
  return i2;
}
var ee;
var oe = { xScale: { type: "point" }, yScale: { type: "linear", min: 0, max: "auto" }, curve: "linear", colors: { scheme: "nivo" }, lineWidth: 2, layers: ["grid", "markers", "axes", "areas", "crosshair", "lines", "points", "slices", "mesh", "legends"], enablePoints: true, pointSize: 6, pointColor: { from: "series.color" }, pointBorderWidth: 0, pointBorderColor: { theme: "background" }, enableArea: false, areaBaselineValue: 0, areaOpacity: 0.2, enableGridX: true, enableGridY: true, legends: [], isInteractive: true, tooltip: (0, import_react.memo)(function(e2) {
  var o2 = e2.point;
  return (0, import_jsx_runtime.jsx)(T, { id: (0, import_jsx_runtime.jsxs)("span", { children: ["x: ", (0, import_jsx_runtime.jsx)("strong", { children: o2.data.xFormatted }), ", y:", " ", (0, import_jsx_runtime.jsx)("strong", { children: o2.data.yFormatted })] }), enableChip: true, color: o2.seriesColor });
}), sliceTooltip: (0, import_react.memo)(function(e2) {
  var o2 = e2.slice, i2 = e2.axis, n2 = M(), t2 = "x" === i2 ? "y" : "x";
  return (0, import_jsx_runtime.jsx)(E, { rows: o2.points.map(function(e3) {
    return [(0, import_jsx_runtime.jsx)(w, { color: e3.seriesColor, style: n2.tooltip.chip }, "chip"), e3.seriesId, (0, import_jsx_runtime.jsx)("span", { style: n2.tooltip.tableCellValue, children: e3.data[t2 + "Formatted"] }, "value")];
  }) });
}), debugMesh: false, renderWrapper: true };
var ie = $({}, oe, { defs: [], fill: [], enablePointLabel: false, pointLabel: "data.yFormatted", areaBlendMode: "normal", axisTop: null, axisRight: null, axisBottom: Y, axisLeft: Y, useMesh: false, enableSlices: false, debugSlices: false, enableCrosshair: true, crosshairType: "bottom-left", enableTouchCrosshair: false, initialHiddenIds: [], animate: true, motionConfig: "gentle", role: "img", isFocusable: false });
var ne = $({}, oe, { pixelRatio: "undefined" != typeof window && null != (ee = window.devicePixelRatio) ? ee : 1, axisTop: null, axisRight: null, axisBottom: Y, axisLeft: Y });
function te(e2) {
  return (0, import_react.useMemo)(function() {
    return line_default().defined(function(e3) {
      return null !== e3.x && null !== e3.y;
    }).x(function(e3) {
      return e3.x;
    }).y(function(e3) {
      return e3.y;
    }).curve(Et(e2));
  }, [e2]);
}
function re(e2) {
  var i2 = e2.curve, n2 = e2.yScale, t2 = e2.areaBaselineValue;
  return (0, import_react.useMemo)(function() {
    return area_default().defined(function(e3) {
      return null !== e3.x && null !== e3.y;
    }).x(function(e3) {
      return e3.x;
    }).y1(function(e3) {
      return e3.y;
    }).curve(Et(i2)).y0(n2(t2));
  }, [i2, n2, t2]);
}
var ae = function(e2) {
  var i2 = e2.componentId, n2 = e2.enableSlices, t2 = e2.points, r2 = e2.width, a2 = e2.height;
  return (0, import_react.useMemo)(function() {
    if ("x" === n2) {
      var e3 = /* @__PURE__ */ new Map();
      return t2.forEach(function(o3) {
        null !== o3.data.x && null !== o3.data.y && (e3.has(o3.x) ? e3.get(o3.x).push(o3) : e3.set(o3.x, [o3]));
      }), Array.from(e3.entries()).sort(function(e4, o3) {
        return e4[0] - o3[0];
      }).map(function(e4, o3, n3) {
        var t3, l2, s2 = e4[0], u = e4[1], d = n3[o3 - 1], c = n3[o3 + 1];
        return t3 = d ? s2 - (s2 - d[0]) / 2 : s2, l2 = c ? s2 - t3 + (c[0] - s2) / 2 : r2 - t3, { id: "slice:" + i2 + ":" + s2, x0: t3, x: s2, y0: 0, y: 0, width: l2, height: a2, points: u.reverse() };
      });
    }
    if ("y" === n2) {
      var o2 = /* @__PURE__ */ new Map();
      return t2.forEach(function(e4) {
        null !== e4.data.x && null !== e4.data.y && (o2.has(e4.y) ? o2.get(e4.y).push(e4) : o2.set(e4.y, [e4]));
      }), Array.from(o2.entries()).sort(function(e4, o3) {
        return e4[0] - o3[0];
      }).map(function(e4, o3, i3) {
        var n3, t3, l2 = e4[0], s2 = e4[1], u = i3[o3 - 1], d = i3[o3 + 1];
        return n3 = u ? l2 - (l2 - u[0]) / 2 : l2, t3 = d ? l2 - n3 + (d[0] - l2) / 2 : a2 - n3, { id: l2, x0: 0, x: 0, y0: n3, y: l2, width: r2, height: t3, points: s2.reverse() };
      });
    }
    return [];
  }, [i2, n2, a2, t2, r2]);
};
var le = "line";
var se = function(e2) {
  var t2 = e2.data, r2 = e2.xScale, a2 = void 0 === r2 ? oe.xScale : r2, l2 = e2.xFormat, s2 = e2.yScale, u = void 0 === s2 ? oe.yScale : s2, c = e2.yFormat, h = e2.width, f = e2.height, p = e2.colors, v = void 0 === p ? oe.colors : p, b = e2.curve, g = void 0 === b ? oe.curve : b, m = e2.areaBaselineValue, y = void 0 === m ? oe.areaBaselineValue : m, x = e2.pointColor, M2 = void 0 === x ? oe.pointColor : x, C = e2.pointBorderColor, S = void 0 === C ? oe.pointBorderColor : C, B = e2.enableSlices, w2 = void 0 === B ? ie.enableSlices : B, T2 = e2.initialHiddenIds, k = void 0 === T2 ? ie.initialHiddenIds : T2, W2 = (0, import_react.useState)((0, import_uniqueId.default)(le))[0], L2 = hn(l2), D = hn(c), I = hr(v, "id"), F2 = M(), E4 = Ye(M2, F2), G = Ye(S, F2), H = (0, import_react.useState)(null != k ? k : []), P = H[0], R = H[1], U2 = (0, import_react.useMemo)(function() {
    return hn2(t2.filter(function(e3) {
      return -1 === P.indexOf(e3.id);
    }), a2, u, h, f);
  }, [t2, P, a2, u, h, f]), X2 = U2.xScale, j4 = U2.yScale, q3 = U2.series, J = (0, import_react.useMemo)(function() {
    var e3 = t2.map(function(e4) {
      return { id: e4.id, label: "" + e4.id, color: I(e4) };
    }), o2 = e3.map(function(e4) {
      return $({}, q3.find(function(o3) {
        return o3.id === e4.id;
      }), { color: e4.color });
    }).filter(function(e4) {
      return Boolean(e4.id);
    });
    return { legendData: e3.map(function(e4) {
      return $({}, e4, { hidden: !o2.find(function(o3) {
        return o3.id === e4.id;
      }) });
    }).reverse(), series: o2 };
  }, [t2, q3, I]), K = J.legendData, N = J.series, Q = (0, import_react.useCallback)(function(e3) {
    R(function(o2) {
      return o2.indexOf(e3) > -1 ? o2.filter(function(o3) {
        return o3 !== e3;
      }) : [].concat(o2, [e3]);
    });
  }, []), Z = function(e3) {
    var i2 = e3.series, n2 = e3.getPointColor, t3 = e3.getPointBorderColor, r3 = e3.formatX, a3 = e3.formatY;
    return (0, import_react.useMemo)(function() {
      return i2.reduce(function(e4, o2, i3) {
        return [].concat(e4, o2.data.filter(function(e5) {
          return null !== e5.position.x && null !== e5.position.y;
        }).map(function(l3, s3) {
          var u2 = { id: o2.id + "." + s3, indexInSeries: s3, absIndex: e4.length + s3, seriesIndex: i3, seriesId: o2.id, seriesColor: o2.color, x: l3.position.x, y: l3.position.y, data: $({}, l3.data, { xFormatted: r3(l3.data.x), yFormatted: a3(l3.data.y) }) };
          return u2.color = n2({ series: o2, point: u2 }), u2.borderColor = t3(u2), u2;
        }));
      }, []);
    }, [i2, n2, t3, r3, a3]);
  }({ series: N, getPointColor: E4, getPointBorderColor: G, formatX: L2, formatY: D }), _2 = ae({ componentId: W2, enableSlices: w2, points: Z, width: h, height: f });
  return { legendData: K, toggleSeries: Q, lineGenerator: te(g), areaGenerator: re({ curve: g, yScale: j4, areaBaselineValue: y }), getColor: I, series: N, xScale: X2, yScale: j4, slices: _2, points: Z };
};
var ue = function(e2) {
  var o2 = e2.areaBlendMode, i2 = e2.areaOpacity, n2 = e2.color, t2 = e2.fill, r2 = e2.path, a2 = Dr(), l2 = a2.animate, s2 = a2.config, u = It(r2), d = useSpring({ color: n2, config: s2, immediate: !l2 });
  return (0, import_jsx_runtime.jsx)(animated.path, { d: u, fill: t2 || d.color, fillOpacity: i2, strokeWidth: 0, style: { mixBlendMode: o2 } });
};
var de = (0, import_react.memo)(function(e2) {
  var o2 = e2.areaGenerator, i2 = e2.areaOpacity, n2 = e2.areaBlendMode, t2 = e2.series.slice(0).reverse();
  return (0, import_jsx_runtime.jsx)("g", { children: t2.map(function(e3) {
    return (0, import_jsx_runtime.jsx)(ue, $({ path: o2(e3.data.map(function(e4) {
      return e4.position;
    })) }, $({ areaOpacity: i2, areaBlendMode: n2 }, e3)), "" + e3.id);
  }) });
});
var ce = (0, import_react.memo)(function(e2) {
  var i2 = e2.lineGenerator, n2 = e2.points, t2 = e2.color, r2 = e2.thickness, a2 = (0, import_react.useMemo)(function() {
    return i2(n2);
  }, [i2, n2]), l2 = It(a2);
  return (0, import_jsx_runtime.jsx)(animated.path, { d: l2, fill: "none", strokeWidth: r2, stroke: t2 });
});
var he = (0, import_react.memo)(function(e2) {
  var o2 = e2.series, i2 = e2.lineGenerator, n2 = e2.lineWidth;
  return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: o2.slice(0).reverse().map(function(e3) {
    var o3 = e3.id, t2 = e3.data, r2 = e3.color;
    return (0, import_jsx_runtime.jsx)(ce, { points: t2.map(function(e4) {
      return e4.position;
    }), lineGenerator: i2, color: r2, thickness: n2 }, o3);
  }) });
});
var fe = (0, import_react.memo)(function(e2) {
  var o2 = e2.slice, i2 = e2.slices, r2 = e2.axis, a2 = e2.debug, l2 = e2.tooltip, s2 = e2.isCurrent, u = e2.setCurrent, d = e2.onMouseEnter, c = e2.onMouseMove, h = e2.onMouseLeave, f = e2.onMouseDown, p = e2.onMouseUp, v = e2.onClick, b = e2.onDoubleClick, g = e2.onTouchStart, m = e2.onTouchMove, y = e2.onTouchEnd, x = z(), M2 = x.showTooltipFromEvent, C = x.hideTooltip, S = (0, import_react.useCallback)(function(e3) {
    M2((0, import_react.createElement)(l2, { slice: o2, axis: r2 }), e3, "right"), u(o2), null == d || d(o2, e3);
  }, [M2, l2, o2, r2, u, d]), B = (0, import_react.useCallback)(function(e3) {
    M2((0, import_react.createElement)(l2, { slice: o2, axis: r2 }), e3, "right"), null == c || c(o2, e3);
  }, [M2, l2, o2, r2, c]), w2 = (0, import_react.useCallback)(function(e3) {
    C(), u(null), null == h || h(o2, e3);
  }, [C, u, h, o2]), T2 = (0, import_react.useCallback)(function(e3) {
    null == f || f(o2, e3);
  }, [o2, f]), k = (0, import_react.useCallback)(function(e3) {
    null == p || p(o2, e3);
  }, [o2, p]), W2 = (0, import_react.useCallback)(function(e3) {
    null == v || v(o2, e3);
  }, [o2, v]), L2 = (0, import_react.useCallback)(function(e3) {
    null == b || b(o2, e3);
  }, [o2, b]), D = (0, import_react.useCallback)(function(e3) {
    M2((0, import_react.createElement)(l2, { slice: o2, axis: r2 }), e3, "right"), u(o2), null == g || g(o2, e3);
  }, [r2, g, u, M2, o2, l2]), I = (0, import_react.useCallback)(function(e3) {
    var n2 = e3.touches[0], a3 = document.elementFromPoint(n2.clientX, n2.clientY), s3 = null == a3 ? void 0 : a3.getAttribute("data-ref");
    if (s3) {
      var d2 = i2.find(function(e4) {
        return e4.id === s3;
      });
      d2 && (M2((0, import_react.createElement)(l2, { slice: d2, axis: r2 }), e3, "right"), u(d2));
    }
    null == m || m(o2, e3);
  }, [r2, m, u, M2, o2, i2, l2]), F2 = (0, import_react.useCallback)(function(e3) {
    C(), u(null), null == y || y(o2, e3);
  }, [C, u, y, o2]);
  return (0, import_jsx_runtime.jsx)("rect", { x: o2.x0, y: o2.y0, width: o2.width, height: o2.height, stroke: "red", strokeWidth: a2 ? 1 : 0, strokeOpacity: 0.75, fill: "red", fillOpacity: s2 && a2 ? 0.35 : 0, onMouseEnter: S, onMouseMove: B, onMouseLeave: w2, onMouseDown: T2, onMouseUp: k, onClick: W2, onDoubleClick: L2, onTouchStart: D, onTouchMove: I, onTouchEnd: F2, "data-ref": o2.id });
});
var pe = (0, import_react.memo)(function(e2) {
  var o2 = e2.slices, i2 = e2.axis, n2 = e2.debug, t2 = e2.tooltip, r2 = e2.current, a2 = e2.setCurrent, l2 = e2.onMouseEnter, s2 = e2.onMouseMove, u = e2.onMouseLeave, d = e2.onMouseDown, c = e2.onMouseUp, h = e2.onClick, f = e2.onDoubleClick, p = e2.onTouchStart, v = e2.onTouchMove, b = e2.onTouchEnd;
  return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: o2.map(function(e3) {
    return (0, import_jsx_runtime.jsx)(fe, { slice: e3, slices: o2, axis: i2, debug: n2, tooltip: t2, setCurrent: a2, isCurrent: null !== r2 && r2.id === e3.id, onMouseEnter: l2, onMouseMove: s2, onMouseLeave: u, onMouseDown: d, onMouseUp: c, onClick: h, onDoubleClick: f, onTouchStart: p, onTouchMove: v, onTouchEnd: b }, e3.id);
  }) });
});
var ve = (0, import_react.memo)(function(e2) {
  var o2 = e2.points, i2 = e2.symbol, n2 = e2.size, r2 = e2.borderWidth, a2 = e2.enableLabel, l2 = e2.label, s2 = e2.labelYOffset, u = e2.isFocusable, d = e2.setCurrentPoint, c = e2.tooltip, h = e2.margin, v = e2.ariaLabel, b = e2.ariaLabelledBy, g = e2.ariaDescribedBy, m = e2.ariaHidden, y = e2.ariaDisabled, x = pn(l2), M2 = z(), C = M2.showTooltipAt, S = M2.hideTooltip, B = o2.slice(0).sort(function(e3, o3) {
    return e3.indexInSeries - o3.indexInSeries;
  }).sort(function(e3, o3) {
    return o3.seriesIndex - e3.seriesIndex;
  }).map(function(e3) {
    return { id: e3.id, x: e3.x, y: e3.y, datum: e3.data, fill: e3.color, stroke: e3.borderColor, label: a2 ? x(e3) : null, ariaLabel: v ? v(e3) : void 0, ariaLabelledBy: b ? b(e3) : void 0, ariaDescribedBy: g ? g(e3) : void 0, ariaHidden: m ? m(e3) : void 0, ariaDisabled: y ? y(e3) : void 0, onFocus: u ? function() {
      d(e3), C((0, import_react.createElement)(c, { point: e3 }), [h.left + e3.x, h.top + e3.y], "top");
    } : void 0, onBlur: u ? function() {
      d(null), S();
    } : void 0 };
  });
  return (0, import_jsx_runtime.jsx)("g", { children: B.map(function(e3) {
    return (0, import_jsx_runtime.jsx)(Ct, { x: e3.x, y: e3.y, datum: e3.datum, symbol: i2, size: n2, color: e3.fill, borderWidth: r2, borderColor: e3.stroke, label: e3.label, labelYOffset: s2, ariaLabel: e3.ariaLabel, ariaLabelledBy: e3.ariaLabelledBy, ariaDescribedBy: e3.ariaDescribedBy, ariaHidden: e3.ariaHidden, ariaDisabled: e3.ariaDisabled, isFocusable: u, onFocus: e3.onFocus, onBlur: e3.onBlur, testId: "line.point." + e3.id }, e3.id);
  }) });
});
var be = (0, import_react.memo)(function(e2) {
  var o2 = e2.points, i2 = e2.width, r2 = e2.height, a2 = e2.margin, l2 = e2.setCurrent, s2 = e2.onMouseEnter, u = e2.onMouseMove, d = e2.onMouseLeave, c = e2.onMouseDown, h = e2.onMouseUp, f = e2.onClick, p = e2.onDoubleClick, v = e2.onTouchStart, b = e2.onTouchMove, g = e2.onTouchEnd, m = e2.tooltip, y = e2.debug, x = e2.enableTouchCrosshair, M2 = z(), C = M2.showTooltipAt, S = M2.hideTooltip, B = (0, import_react.useCallback)(function(e3, o3) {
    C((0, import_react.createElement)(m, { point: e3 }), [e3.x + a2.left, e3.y + a2.top], "top"), null == s2 || s2(e3, o3);
  }, [C, m, s2, a2]), w2 = (0, import_react.useCallback)(function(e3, o3) {
    C((0, import_react.createElement)(m, { point: e3 }), [e3.x + a2.left, e3.y + a2.top], "top"), null == u || u(e3, o3);
  }, [C, m, a2.left, a2.top, u]), T2 = (0, import_react.useCallback)(function(e3, o3) {
    S(), null == d || d(e3, o3);
  }, [S, d]), k = (0, import_react.useCallback)(function(e3, o3) {
    null == c || c(e3, o3);
  }, [c]), W2 = (0, import_react.useCallback)(function(e3, o3) {
    null == h || h(e3, o3);
  }, [h]), L2 = (0, import_react.useCallback)(function(e3, o3) {
    null == f || f(e3, o3);
  }, [f]), D = (0, import_react.useCallback)(function(e3, o3) {
    null == p || p(e3, o3);
  }, [p]), I = (0, import_react.useCallback)(function(e3, o3) {
    C((0, import_react.createElement)(m, { point: e3 }), [e3.x + a2.left, e3.y + a2.top], "top"), null == v || v(e3, o3);
  }, [a2.left, a2.top, v, C, m]), F2 = (0, import_react.useCallback)(function(e3, o3) {
    C((0, import_react.createElement)(m, { point: e3 }), [e3.x + a2.left, e3.y + a2.top], "top"), null == b || b(e3, o3);
  }, [a2.left, a2.top, b, C, m]), E4 = (0, import_react.useCallback)(function(e3, o3) {
    S(), null == g || g(e3, o3);
  }, [g, S]);
  return (0, import_jsx_runtime.jsx)(j2, { nodes: o2, width: i2, height: r2, setCurrent: l2, onMouseEnter: B, onMouseMove: w2, onMouseLeave: T2, onMouseDown: k, onMouseUp: W2, onClick: L2, onDoubleClick: D, onTouchStart: I, onTouchMove: F2, onTouchEnd: E4, enableTouchCrosshair: x, debug: y });
});
var ge = ["isInteractive", "animate", "motionConfig", "theme", "renderWrapper"];
function me(e2) {
  var o2 = e2.data, n2 = e2.xScale, t2 = void 0 === n2 ? ie.xScale : n2, r2 = e2.xFormat, l2 = e2.yScale, s2 = void 0 === l2 ? ie.yScale : l2, u = e2.yFormat, d = e2.curve, c = void 0 === d ? ie.curve : d, h = e2.margin, f = e2.width, p = e2.height, v = e2.colors, x = void 0 === v ? ie.colors : v, M2 = e2.lineWidth, C = void 0 === M2 ? ie.lineWidth : M2, S = e2.layers, B = void 0 === S ? ie.layers : S, k = e2.enableArea, W2 = void 0 === k ? ie.enableArea : k, D = e2.areaBaselineValue, I = void 0 === D ? ie.areaBaselineValue : D, F2 = e2.areaOpacity, E4 = void 0 === F2 ? ie.areaOpacity : F2, G = e2.areaBlendMode, P = void 0 === G ? ie.areaBlendMode : G, R = e2.enablePoints, O2 = void 0 === R ? ie.enablePoints : R, z2 = e2.pointSymbol, A = e2.pointSize, V3 = void 0 === A ? ie.pointSize : A, Y2 = e2.pointColor, X2 = void 0 === Y2 ? ie.pointColor : Y2, j4 = e2.pointBorderWidth, q3 = void 0 === j4 ? ie.pointBorderWidth : j4, J = e2.pointBorderColor, K = void 0 === J ? ie.pointBorderColor : J, N = e2.enablePointLabel, Q = void 0 === N ? ie.enablePointLabel : N, Z = e2.pointLabel, _2 = void 0 === Z ? ie.pointLabel : Z, ee2 = e2.pointLabelYOffset, oe2 = e2.enableGridX, ne2 = void 0 === oe2 ? ie.enableGridX : oe2, te2 = e2.gridXValues, re2 = e2.enableGridY, ae2 = void 0 === re2 ? ie.enableGridY : re2, le2 = e2.gridYValues, ue2 = e2.axisTop, ce2 = e2.axisRight, fe2 = e2.axisBottom, ge2 = void 0 === fe2 ? ie.axisBottom : fe2, me2 = e2.axisLeft, ye2 = void 0 === me2 ? ie.axisLeft : me2, xe2 = e2.defs, Me2 = void 0 === xe2 ? ie.defs : xe2, Ce2 = e2.fill, Se2 = void 0 === Ce2 ? ie.fill : Ce2, Be2 = e2.markers, we2 = e2.legends, Te2 = void 0 === we2 ? ie.legends : we2, ke2 = e2.isInteractive, We2 = void 0 === ke2 ? ie.isInteractive : ke2, Le = e2.useMesh, De = void 0 === Le ? ie.useMesh : Le, Ie = e2.debugMesh, Fe = void 0 === Ie ? ie.debugMesh : Ie, Ee = e2.onMouseEnter, Ge = e2.onMouseMove, He = e2.onMouseLeave, Pe = e2.onMouseDown, Re = e2.onMouseUp, Oe = e2.onClick, ze = e2.onDoubleClick, Ae = e2.onTouchStart, Ve = e2.onTouchMove, Ye2 = e2.onTouchEnd, Ue = e2.tooltip, Xe = void 0 === Ue ? ie.tooltip : Ue, je = e2.enableSlices, qe = void 0 === je ? ie.enableSlices : je, Je = e2.debugSlices, Ke = void 0 === Je ? ie.debugSlices : Je, Ne = e2.sliceTooltip, Qe = void 0 === Ne ? ie.sliceTooltip : Ne, Ze = e2.enableCrosshair, $e = void 0 === Ze ? ie.enableCrosshair : Ze, _e = e2.crosshairType, eo = void 0 === _e ? ie.crosshairType : _e, oo = e2.enableTouchCrosshair, io = void 0 === oo ? ie.enableTouchCrosshair : oo, no = e2.role, to = void 0 === no ? ie.role : no, ro = e2.ariaLabel, ao = e2.ariaLabelledBy, lo = e2.ariaDescribedBy, so = e2.isFocusable, uo = void 0 === so ? ie.isFocusable : so, co = e2.pointAriaLabel, ho = e2.pointAriaLabelledBy, fo = e2.pointAriaDescribedBy, po = e2.pointAriaHidden, vo = e2.pointAriaDisabled, bo = e2.initialHiddenIds, go = void 0 === bo ? ie.initialHiddenIds : bo, mo = e2.forwardedRef, yo = cn(f, p, h), xo = yo.margin, Mo = yo.innerWidth, Co = yo.innerHeight, So = yo.outerWidth, Bo = yo.outerHeight, wo = se({ data: o2, xScale: t2, xFormat: r2, yScale: s2, yFormat: u, width: Mo, height: Co, colors: x, curve: c, areaBaselineValue: I, pointColor: X2, pointBorderColor: K, enableSlices: qe, initialHiddenIds: go }), To = wo.legendData, ko = wo.toggleSeries, Wo = wo.lineGenerator, Lo = wo.areaGenerator, Do = wo.series, Io = wo.xScale, Fo = wo.yScale, Eo = wo.slices, Go = wo.points, Ho = (0, import_react.useState)(null), Po = Ho[0], Ro = Ho[1], Oo = (0, import_react.useState)(null), zo = Oo[0], Ao = Oo[1], Vo = { grid: null, markers: null, axes: null, areas: null, crosshair: null, lines: null, points: null, slices: null, mesh: null, legends: null };
  B.includes("grid") && (ne2 || ae2) && (Vo.grid = (0, import_jsx_runtime.jsx)(j, { width: Mo, height: Co, xScale: ne2 ? Io : null, yScale: ae2 ? Fo : null, xValues: te2, yValues: le2 }, "grid")), B.includes("markers") && Array.isArray(Be2) && Be2.length > 0 && (Vo.markers = (0, import_jsx_runtime.jsx)(Pt, { markers: Be2, width: Mo, height: Co, xScale: Io, yScale: Fo }, "markers")), B.includes("axes") && (Vo.axes = (0, import_jsx_runtime.jsx)(V2, { xScale: Io, yScale: Fo, width: Mo, height: Co, top: ue2, right: ce2, bottom: ge2, left: ye2 }, "axes")), B.includes("lines") && (Vo.lines = (0, import_jsx_runtime.jsx)(he, { series: Do, lineGenerator: Wo, lineWidth: C }, "lines")), B.includes("legends") && Te2.length > 0 && (Vo.legends = (0, import_jsx_runtime.jsx)(import_react.Fragment, { children: Te2.map(function(e3, o3) {
    return (0, import_jsx_runtime.jsx)(E2, $({}, e3, { containerWidth: Mo, containerHeight: Co, data: e3.data || To, toggleSerie: e3.toggleSerie ? ko : void 0 }), o3);
  }) }, "legends"));
  var Yo = Mn(Me2, Do, Se2);
  W2 && (Vo.areas = (0, import_jsx_runtime.jsx)(de, { areaGenerator: Lo, areaOpacity: E4, areaBlendMode: P, series: Do }, "areas")), We2 && false !== qe && (Vo.slices = (0, import_jsx_runtime.jsx)(pe, { slices: Eo, axis: qe, debug: Ke, tooltip: Qe, current: zo, setCurrent: Ao, onMouseEnter: Ee, onMouseMove: Ge, onMouseLeave: He, onMouseDown: Pe, onMouseUp: Re, onClick: Oe, onDoubleClick: ze, onTouchStart: Ae, onTouchMove: Ve, onTouchEnd: Ye2 }, "slices")), O2 && (Vo.points = (0, import_jsx_runtime.jsx)(ve, { points: Go, symbol: z2, size: V3, borderWidth: q3, enableLabel: Q, label: _2, labelYOffset: ee2, isFocusable: uo, setCurrentPoint: Ro, tooltip: Xe, margin: xo, ariaLabel: co, ariaLabelledBy: ho, ariaDescribedBy: fo, ariaHidden: po, ariaDisabled: vo }, "points")), We2 && $e && (null !== Po && (Vo.crosshair = (0, import_jsx_runtime.jsx)(V, { width: Mo, height: Co, x: Po.x, y: Po.y, type: eo }, "crosshair")), null !== zo && qe && (Vo.crosshair = (0, import_jsx_runtime.jsx)(V, { width: Mo, height: Co, x: zo.x, y: zo.y, type: qe }, "crosshair"))), We2 && De && false === qe && (Vo.mesh = (0, import_jsx_runtime.jsx)(be, { points: Go, width: Mo, height: Co, margin: xo, setCurrent: Ro, onMouseEnter: Ee, onMouseMove: Ge, onMouseLeave: He, onMouseDown: Pe, onMouseUp: Re, onClick: Oe, onDoubleClick: ze, onTouchStart: Ae, onTouchMove: Ve, onTouchEnd: Ye2, tooltip: Xe, enableTouchCrosshair: io, debug: Fe }, "mesh"));
  var Uo = $({}, e2, { innerWidth: Mo, innerHeight: Co, series: Do, slices: Eo, points: Go, xScale: Io, yScale: Fo, lineGenerator: Wo, areaGenerator: Lo, currentPoint: Po, setCurrentPoint: Ro, currentSlice: zo, setCurrentSlice: Ao });
  return (0, import_jsx_runtime.jsx)(Rt, { defs: Yo, width: So, height: Bo, margin: xo, role: to, ariaLabel: ro, ariaLabelledBy: ao, ariaDescribedBy: lo, isFocusable: uo, ref: mo, children: B.map(function(e3, o3) {
    return "function" == typeof e3 ? (0, import_jsx_runtime.jsx)(import_react.Fragment, { children: e3(Uo) }, o3) : Vo[e3];
  }) });
}
var ye = (0, import_react.forwardRef)(function(e2, o2) {
  var i2 = e2.isInteractive, n2 = void 0 === i2 ? ie.isInteractive : i2, t2 = e2.animate, r2 = void 0 === t2 ? ie.animate : t2, a2 = e2.motionConfig, l2 = void 0 === a2 ? ie.motionConfig : a2, s2 = e2.theme, u = e2.renderWrapper, d = _(e2, ge);
  return (0, import_jsx_runtime.jsx)(Fr, { animate: r2, isInteractive: n2, motionConfig: l2, renderWrapper: u, theme: s2, children: (0, import_jsx_runtime.jsx)(me, $({ isInteractive: n2 }, d, { forwardedRef: o2 })) });
});
var xe = ["defaultWidth", "defaultHeight", "onResize", "debounceResize"];
var Me = (0, import_react.forwardRef)(function(e2, o2) {
  var i2 = e2.defaultWidth, n2 = e2.defaultHeight, t2 = e2.onResize, r2 = e2.debounceResize, a2 = _(e2, xe);
  return (0, import_jsx_runtime.jsx)($r, { defaultWidth: i2, defaultHeight: n2, onResize: t2, debounceResize: r2, children: function(e3) {
    var i3 = e3.width, n3 = e3.height;
    return (0, import_jsx_runtime.jsx)(ye, $({ width: i3, height: n3 }, a2, { ref: o2 }));
  } });
});
var Ce = ["isInteractive", "renderWrapper", "theme"];
var Se = function(e2) {
  var r2 = e2.width, a2 = e2.height, u = e2.margin, d = e2.pixelRatio, c = void 0 === d ? ne.pixelRatio : d, h = e2.data, f = e2.xScale, p = void 0 === f ? ne.xScale : f, v = e2.xFormat, g = e2.yScale, m = void 0 === g ? ne.yScale : g, y = e2.yFormat, x = e2.curve, B = void 0 === x ? ne.curve : x, w2 = e2.layers, T2 = void 0 === w2 ? ne.layers : w2, L2 = e2.colors, I = void 0 === L2 ? ne.colors : L2, F2 = e2.lineWidth, E4 = void 0 === F2 ? ne.lineWidth : F2, H = e2.enableArea, P = void 0 === H ? ne.enableArea : H, R = e2.areaBaselineValue, O2 = void 0 === R ? ne.areaBaselineValue : R, A = e2.areaOpacity, V3 = void 0 === A ? ne.areaOpacity : A, Y2 = e2.enablePoints, X2 = void 0 === Y2 ? ne.enablePoints : Y2, j4 = e2.pointSize, q3 = void 0 === j4 ? ne.pointSize : j4, J = e2.pointColor, K = void 0 === J ? ne.pointColor : J, _2 = e2.pointBorderWidth, ee2 = void 0 === _2 ? ne.pointBorderWidth : _2, oe2 = e2.pointBorderColor, ie2 = void 0 === oe2 ? ne.pointBorderColor : oe2, te2 = e2.enableGridX, re2 = void 0 === te2 ? ne.enableGridX : te2, ae2 = e2.gridXValues, le2 = e2.enableGridY, ue2 = void 0 === le2 ? ne.enableGridY : le2, de2 = e2.gridYValues, ce2 = e2.axisTop, he2 = e2.axisRight, fe2 = e2.axisBottom, pe2 = void 0 === fe2 ? ne.axisBottom : fe2, ve2 = e2.axisLeft, be2 = void 0 === ve2 ? ne.axisLeft : ve2, ge2 = e2.legends, me2 = void 0 === ge2 ? ne.legends : ge2, ye2 = e2.isInteractive, xe2 = void 0 === ye2 ? ne.isInteractive : ye2, Me2 = e2.debugMesh, Ce2 = void 0 === Me2 ? ne.debugMesh : Me2, Se2 = e2.onMouseLeave, Be2 = e2.onMouseDown, we2 = e2.onMouseUp, Te2 = e2.onClick, ke2 = e2.onDoubleClick, We2 = e2.tooltip, Le = void 0 === We2 ? ne.tooltip : We2, De = e2.role, Ie = e2.forwardedRef, Fe = (0, import_react.useRef)(null), Ee = cn(r2, a2, u), Ge = Ee.margin, He = Ee.innerWidth, Pe = Ee.innerHeight, Re = Ee.outerWidth, Oe = Ee.outerHeight, ze = M(), Ae = (0, import_react.useState)(null), Ve = Ae[0], Ye2 = Ae[1], Ue = se({ data: h, xScale: p, xFormat: v, yScale: m, yFormat: y, width: He, height: Pe, colors: I, curve: B, areaBaselineValue: O2, pointColor: K, pointBorderColor: ie2 }), Xe = Ue.lineGenerator, je = Ue.areaGenerator, qe = Ue.series, Je = Ue.xScale, Ke = Ue.yScale, Ne = Ue.points, Qe = (0, import_react.useMemo)(function() {
    return { innerWidth: He, innerHeight: Pe, series: qe, points: Ne, xScale: Je, yScale: Ke, lineWidth: E4, lineGenerator: Xe, areaGenerator: je, currentPoint: Ve, setCurrentPoint: Ye2 };
  }, [He, Pe, qe, Ne, Je, Ke, E4, Xe, je, Ve, Ye2]), Ze = E3({ points: Ne, width: He, height: Pe, debug: Ce2 }), $e = Ze.delaunay, _e = Ze.voronoi;
  (0, import_react.useEffect)(function() {
    if (null !== Fe.current) {
      Fe.current.width = Re * c, Fe.current.height = Oe * c;
      var e3 = Fe.current.getContext("2d");
      e3.scale(c, c), e3.fillStyle = ze.background, e3.fillRect(0, 0, Re, Oe), e3.translate(Ge.left, Ge.top), T2.forEach(function(o2) {
        var i2;
        "function" == typeof o2 && o2(e3, Qe);
        var n2 = null != (i2 = ze.grid.line.strokeWidth) ? i2 : 0;
        if ("grid" === o2 && "string" != typeof n2 && n2 > 0 && (e3.lineWidth = n2, e3.strokeStyle = ze.grid.line.stroke, re2 && q(e3, { width: He, height: Pe, scale: Je, axis: "x", values: ae2 }), ue2 && q(e3, { width: He, height: Pe, scale: Ke, axis: "y", values: de2 })), "axes" === o2 && W(e3, { xScale: Je, yScale: Ke, width: He, height: Pe, top: ce2, right: he2, bottom: pe2, left: be2, theme: ze }), "areas" === o2 && true === P) {
          e3.save(), e3.globalAlpha = V3, je.context(e3);
          for (var t2 = qe.length - 1; t2 >= 0; t2--) e3.fillStyle = qe[t2].color, e3.beginPath(), je(qe[t2].data.map(function(e4) {
            return e4.position;
          })), e3.fill();
          e3.restore();
        }
        if ("lines" === o2 && (Xe.context(e3), qe.forEach(function(o3) {
          e3.strokeStyle = o3.color, e3.lineWidth = E4, e3.beginPath(), Xe(o3.data.map(function(e4) {
            return e4.position;
          })), e3.stroke();
        })), "points" === o2 && true === X2 && q3 > 0 && Ne.forEach(function(o3) {
          e3.fillStyle = o3.color, e3.beginPath(), e3.arc(o3.x, o3.y, q3 / 2, 0, 2 * Math.PI), e3.fill(), ee2 > 0 && (e3.strokeStyle = o3.borderColor, e3.lineWidth = ee2, e3.stroke());
        }), "mesh" === o2 && true === Ce2 && void 0 !== _e && (F(e3, _e), Ve && q2(e3, _e, Ve.absIndex)), "legends" === o2) {
          var r3 = qe.map(function(e4) {
            return { id: e4.id, label: e4.id, color: e4.color };
          }).reverse();
          me2.forEach(function(o3) {
            L(e3, $({}, o3, { data: o3.data || r3, containerWidth: He, containerHeight: Pe, theme: ze }));
          });
        }
      });
    }
  }, [Fe, He, Re, Pe, Oe, Ge.left, Ge.top, c, T2, ze, Xe, qe, Je, Ke, re2, ae2, ue2, de2, ce2, he2, pe2, be2, me2, Ne, X2, q3, ee2, Ve, Qe, Ce2, P, je, V3, E4, _e]);
  var eo = (0, import_react.useCallback)(function(e3) {
    if (!Fe.current) return null;
    var o2 = kn(Fe.current, e3), i2 = o2[0], n2 = o2[1];
    if (!wn(Ge.left, Ge.top, He, Pe, i2, n2)) return null;
    var t2 = $e.find(i2 - Ge.left, n2 - Ge.top);
    return Ne[t2];
  }, [Fe, Ge, He, Pe, $e, Ne]), oo = z(), io = oo.showTooltipFromEvent, no = oo.hideTooltip, to = (0, import_react.useCallback)(function(e3) {
    var o2 = eo(e3);
    Ye2(o2), o2 ? io((0, import_react.createElement)(Le, { point: o2 }), e3) : no();
  }, [eo, Ye2, io, no, Le]), ro = (0, import_react.useCallback)(function(e3) {
    no(), Ye2(null), Ve && (null == Se2 || Se2(Ve, e3));
  }, [no, Ye2, Se2, Ve]), ao = (0, import_react.useCallback)(function(e3) {
    if (Be2) {
      var o2 = eo(e3);
      o2 && Be2(o2, e3);
    }
  }, [eo, Be2]), lo = (0, import_react.useCallback)(function(e3) {
    if (we2) {
      var o2 = eo(e3);
      o2 && we2(o2, e3);
    }
  }, [eo, we2]), so = (0, import_react.useCallback)(function(e3) {
    if (Te2) {
      var o2 = eo(e3);
      o2 && Te2(o2, e3);
    }
  }, [eo, Te2]), uo = (0, import_react.useCallback)(function(e3) {
    if (ke2) {
      var o2 = eo(e3);
      o2 && ke2(o2, e3);
    }
  }, [eo, ke2]);
  return (0, import_jsx_runtime.jsx)("canvas", { ref: Rn(Fe, Ie), width: Re * c, height: Oe * c, style: { width: Re, height: Oe, cursor: xe2 ? "auto" : "normal" }, onMouseEnter: xe2 ? to : void 0, onMouseMove: xe2 ? to : void 0, onMouseLeave: xe2 ? ro : void 0, onMouseDown: xe2 ? ao : void 0, onMouseUp: xe2 ? lo : void 0, onClick: xe2 ? so : void 0, onDoubleClick: xe2 ? uo : void 0, role: De });
};
var Be = (0, import_react.forwardRef)(function(e2, o2) {
  var i2 = e2.isInteractive, n2 = e2.renderWrapper, t2 = e2.theme, r2 = _(e2, Ce);
  return (0, import_jsx_runtime.jsx)(Fr, { isInteractive: i2, renderWrapper: n2, theme: t2, animate: false, children: (0, import_jsx_runtime.jsx)(Se, $({}, r2, { forwardedRef: o2 })) });
});
var we = ["defaultWidth", "defaultHeight", "onResize", "debounceResize"];
var Te = (0, import_react.forwardRef)(function(e2, o2) {
  var i2 = e2.defaultWidth;
  e2.defaultHeight;
  var n2 = e2.onResize, t2 = e2.debounceResize, r2 = _(e2, we);
  return (0, import_jsx_runtime.jsx)($r, { defaultWidth: i2, defaultHeight: i2, onResize: n2, debounceResize: t2, children: function(e3) {
    var i3 = e3.width, n3 = e3.height;
    return (0, import_jsx_runtime.jsx)(Be, $({ width: i3, height: n3 }, r2, { ref: o2 }));
  } });
});
function ke(e2) {
  return void 0 !== e2.seriesId;
}
function We(e2) {
  return void 0 !== e2.points;
}
export {
  le as LINE_UNIQUE_ID_PREFIX,
  ye as Line,
  Be as LineCanvas,
  Me as ResponsiveLine,
  Te as ResponsiveLineCanvas,
  ne as canvasDefaultProps,
  oe as commonDefaultProps,
  ke as isPoint,
  We as isSliceData,
  ie as svgDefaultProps,
  re as useAreaGenerator,
  se as useLine,
  te as useLineGenerator,
  ae as useSlices
};
//# sourceMappingURL=@nivo_line.js.map
