{
  "version": 3,
  "sources": ["../../lodash/uniqueId.js", "../../@nivo/line/node_modules/@react-spring/web/dist/react-spring_web.modern.mjs", "../../@nivo/line/src/PointTooltip.tsx", "../../@nivo/line/src/defaults.ts", "../../@nivo/line/src/SliceTooltip.tsx", "../../@nivo/line/src/hooks.ts", "../../@nivo/line/src/Areas.tsx", "../../@nivo/line/src/LinesItem.tsx", "../../@nivo/line/src/Lines.tsx", "../../@nivo/line/src/SlicesItem.tsx", "../../@nivo/line/src/Slices.tsx", "../../@nivo/line/src/Points.tsx", "../../@nivo/line/src/Mesh.tsx", "../../@nivo/line/src/Line.tsx", "../../@nivo/line/src/ResponsiveLine.tsx", "../../@nivo/line/src/LineCanvas.tsx", "../../@nivo/line/src/ResponsiveLineCanvas.tsx", "../../@nivo/line/src/types.ts"],
  "sourcesContent": ["var toString = require('./toString');\n\n/** Used to generate unique IDs. */\nvar idCounter = 0;\n\n/**\n * Generates a unique ID. If `prefix` is given, the ID is appended to it.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {string} [prefix=''] The value to prefix the ID with.\n * @returns {string} Returns the unique ID.\n * @example\n *\n * _.uniqueId('contact_');\n * // => 'contact_104'\n *\n * _.uniqueId();\n * // => '105'\n */\nfunction uniqueId(prefix) {\n  var id = ++idCounter;\n  return toString(prefix) + id;\n}\n\nmodule.exports = uniqueId;\n", "// src/index.ts\nimport { Globals } from \"@react-spring/core\";\nimport { unstable_batchedUpdates } from \"react-dom\";\nimport { createStringInterpolator, colors } from \"@react-spring/shared\";\nimport { createHost } from \"@react-spring/animated\";\n\n// src/applyAnimatedValues.ts\nvar isCustomPropRE = /^--/;\nfunction dangerousStyleValue(name, value) {\n  if (value == null || typeof value === \"boolean\" || value === \"\") return \"\";\n  if (typeof value === \"number\" && value !== 0 && !isCustomPropRE.test(name) && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]))\n    return value + \"px\";\n  return (\"\" + value).trim();\n}\nvar attributeCache = {};\nfunction applyAnimatedValues(instance, props) {\n  if (!instance.nodeType || !instance.setAttribute) {\n    return false;\n  }\n  const isFilterElement = instance.nodeName === \"filter\" || instance.parentNode && instance.parentNode.nodeName === \"filter\";\n  const {\n    className,\n    style,\n    children,\n    scrollTop,\n    scrollLeft,\n    viewBox,\n    ...attributes\n  } = props;\n  const values = Object.values(attributes);\n  const names = Object.keys(attributes).map(\n    (name) => isFilterElement || instance.hasAttribute(name) ? name : attributeCache[name] || (attributeCache[name] = name.replace(\n      /([A-Z])/g,\n      // Attributes are written in dash case\n      (n) => \"-\" + n.toLowerCase()\n    ))\n  );\n  if (children !== void 0) {\n    instance.textContent = children;\n  }\n  for (const name in style) {\n    if (style.hasOwnProperty(name)) {\n      const value = dangerousStyleValue(name, style[name]);\n      if (isCustomPropRE.test(name)) {\n        instance.style.setProperty(name, value);\n      } else {\n        instance.style[name] = value;\n      }\n    }\n  }\n  names.forEach((name, i) => {\n    instance.setAttribute(name, values[i]);\n  });\n  if (className !== void 0) {\n    instance.className = className;\n  }\n  if (scrollTop !== void 0) {\n    instance.scrollTop = scrollTop;\n  }\n  if (scrollLeft !== void 0) {\n    instance.scrollLeft = scrollLeft;\n  }\n  if (viewBox !== void 0) {\n    instance.setAttribute(\"viewBox\", viewBox);\n  }\n}\nvar isUnitlessNumber = {\n  animationIterationCount: true,\n  borderImageOutset: true,\n  borderImageSlice: true,\n  borderImageWidth: true,\n  boxFlex: true,\n  boxFlexGroup: true,\n  boxOrdinalGroup: true,\n  columnCount: true,\n  columns: true,\n  flex: true,\n  flexGrow: true,\n  flexPositive: true,\n  flexShrink: true,\n  flexNegative: true,\n  flexOrder: true,\n  gridRow: true,\n  gridRowEnd: true,\n  gridRowSpan: true,\n  gridRowStart: true,\n  gridColumn: true,\n  gridColumnEnd: true,\n  gridColumnSpan: true,\n  gridColumnStart: true,\n  fontWeight: true,\n  lineClamp: true,\n  lineHeight: true,\n  opacity: true,\n  order: true,\n  orphans: true,\n  tabSize: true,\n  widows: true,\n  zIndex: true,\n  zoom: true,\n  // SVG-related properties\n  fillOpacity: true,\n  floodOpacity: true,\n  stopOpacity: true,\n  strokeDasharray: true,\n  strokeDashoffset: true,\n  strokeMiterlimit: true,\n  strokeOpacity: true,\n  strokeWidth: true\n};\nvar prefixKey = (prefix, key) => prefix + key.charAt(0).toUpperCase() + key.substring(1);\nvar prefixes = [\"Webkit\", \"Ms\", \"Moz\", \"O\"];\nisUnitlessNumber = Object.keys(isUnitlessNumber).reduce((acc, prop) => {\n  prefixes.forEach((prefix) => acc[prefixKey(prefix, prop)] = acc[prop]);\n  return acc;\n}, isUnitlessNumber);\n\n// src/AnimatedStyle.ts\nimport { AnimatedObject } from \"@react-spring/animated\";\nimport {\n  is,\n  each,\n  toArray,\n  eachProp,\n  FluidValue,\n  getFluidValue,\n  callFluidObservers,\n  hasFluidValue,\n  addFluidObserver,\n  removeFluidObserver\n} from \"@react-spring/shared\";\nvar domTransforms = /^(matrix|translate|scale|rotate|skew)/;\nvar pxTransforms = /^(translate)/;\nvar degTransforms = /^(rotate|skew)/;\nvar addUnit = (value, unit) => is.num(value) && value !== 0 ? value + unit : value;\nvar isValueIdentity = (value, id) => is.arr(value) ? value.every((v) => isValueIdentity(v, id)) : is.num(value) ? value === id : parseFloat(value) === id;\nvar AnimatedStyle = class extends AnimatedObject {\n  constructor({ x, y, z, ...style }) {\n    const inputs = [];\n    const transforms = [];\n    if (x || y || z) {\n      inputs.push([x || 0, y || 0, z || 0]);\n      transforms.push((xyz) => [\n        `translate3d(${xyz.map((v) => addUnit(v, \"px\")).join(\",\")})`,\n        // prettier-ignore\n        isValueIdentity(xyz, 0)\n      ]);\n    }\n    eachProp(style, (value, key) => {\n      if (key === \"transform\") {\n        inputs.push([value || \"\"]);\n        transforms.push((transform) => [transform, transform === \"\"]);\n      } else if (domTransforms.test(key)) {\n        delete style[key];\n        if (is.und(value)) return;\n        const unit = pxTransforms.test(key) ? \"px\" : degTransforms.test(key) ? \"deg\" : \"\";\n        inputs.push(toArray(value));\n        transforms.push(\n          key === \"rotate3d\" ? ([x2, y2, z2, deg]) => [\n            `rotate3d(${x2},${y2},${z2},${addUnit(deg, unit)})`,\n            isValueIdentity(deg, 0)\n          ] : (input) => [\n            `${key}(${input.map((v) => addUnit(v, unit)).join(\",\")})`,\n            isValueIdentity(input, key.startsWith(\"scale\") ? 1 : 0)\n          ]\n        );\n      }\n    });\n    if (inputs.length) {\n      style.transform = new FluidTransform(inputs, transforms);\n    }\n    super(style);\n  }\n};\nvar FluidTransform = class extends FluidValue {\n  constructor(inputs, transforms) {\n    super();\n    this.inputs = inputs;\n    this.transforms = transforms;\n    this._value = null;\n  }\n  get() {\n    return this._value || (this._value = this._get());\n  }\n  _get() {\n    let transform = \"\";\n    let identity = true;\n    each(this.inputs, (input, i) => {\n      const arg1 = getFluidValue(input[0]);\n      const [t, id] = this.transforms[i](\n        is.arr(arg1) ? arg1 : input.map(getFluidValue)\n      );\n      transform += \" \" + t;\n      identity = identity && id;\n    });\n    return identity ? \"none\" : transform;\n  }\n  // Start observing our inputs once we have an observer.\n  observerAdded(count) {\n    if (count == 1)\n      each(\n        this.inputs,\n        (input) => each(\n          input,\n          (value) => hasFluidValue(value) && addFluidObserver(value, this)\n        )\n      );\n  }\n  // Stop observing our inputs once we have no observers.\n  observerRemoved(count) {\n    if (count == 0)\n      each(\n        this.inputs,\n        (input) => each(\n          input,\n          (value) => hasFluidValue(value) && removeFluidObserver(value, this)\n        )\n      );\n  }\n  eventObserved(event) {\n    if (event.type == \"change\") {\n      this._value = null;\n    }\n    callFluidObservers(this, event);\n  }\n};\n\n// src/primitives.ts\nvar primitives = [\n  \"a\",\n  \"abbr\",\n  \"address\",\n  \"area\",\n  \"article\",\n  \"aside\",\n  \"audio\",\n  \"b\",\n  \"base\",\n  \"bdi\",\n  \"bdo\",\n  \"big\",\n  \"blockquote\",\n  \"body\",\n  \"br\",\n  \"button\",\n  \"canvas\",\n  \"caption\",\n  \"cite\",\n  \"code\",\n  \"col\",\n  \"colgroup\",\n  \"data\",\n  \"datalist\",\n  \"dd\",\n  \"del\",\n  \"details\",\n  \"dfn\",\n  \"dialog\",\n  \"div\",\n  \"dl\",\n  \"dt\",\n  \"em\",\n  \"embed\",\n  \"fieldset\",\n  \"figcaption\",\n  \"figure\",\n  \"footer\",\n  \"form\",\n  \"h1\",\n  \"h2\",\n  \"h3\",\n  \"h4\",\n  \"h5\",\n  \"h6\",\n  \"head\",\n  \"header\",\n  \"hgroup\",\n  \"hr\",\n  \"html\",\n  \"i\",\n  \"iframe\",\n  \"img\",\n  \"input\",\n  \"ins\",\n  \"kbd\",\n  \"keygen\",\n  \"label\",\n  \"legend\",\n  \"li\",\n  \"link\",\n  \"main\",\n  \"map\",\n  \"mark\",\n  \"menu\",\n  \"menuitem\",\n  \"meta\",\n  \"meter\",\n  \"nav\",\n  \"noscript\",\n  \"object\",\n  \"ol\",\n  \"optgroup\",\n  \"option\",\n  \"output\",\n  \"p\",\n  \"param\",\n  \"picture\",\n  \"pre\",\n  \"progress\",\n  \"q\",\n  \"rp\",\n  \"rt\",\n  \"ruby\",\n  \"s\",\n  \"samp\",\n  \"script\",\n  \"section\",\n  \"select\",\n  \"small\",\n  \"source\",\n  \"span\",\n  \"strong\",\n  \"style\",\n  \"sub\",\n  \"summary\",\n  \"sup\",\n  \"table\",\n  \"tbody\",\n  \"td\",\n  \"textarea\",\n  \"tfoot\",\n  \"th\",\n  \"thead\",\n  \"time\",\n  \"title\",\n  \"tr\",\n  \"track\",\n  \"u\",\n  \"ul\",\n  \"var\",\n  \"video\",\n  \"wbr\",\n  // SVG\n  \"circle\",\n  \"clipPath\",\n  \"defs\",\n  \"ellipse\",\n  \"foreignObject\",\n  \"g\",\n  \"image\",\n  \"line\",\n  \"linearGradient\",\n  \"mask\",\n  \"path\",\n  \"pattern\",\n  \"polygon\",\n  \"polyline\",\n  \"radialGradient\",\n  \"rect\",\n  \"stop\",\n  \"svg\",\n  \"text\",\n  \"tspan\"\n];\n\n// src/index.ts\nexport * from \"@react-spring/core\";\nGlobals.assign({\n  batchedUpdates: unstable_batchedUpdates,\n  createStringInterpolator,\n  colors\n});\nvar host = createHost(primitives, {\n  applyAnimatedValues,\n  createAnimatedStyle: (style) => new AnimatedStyle(style),\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  getComponentProps: ({ scrollTop, scrollLeft, ...props }) => props\n});\nvar animated = host.animated;\nexport {\n  animated as a,\n  animated\n};\n", "import { memo } from 'react'\nimport { BasicTooltip } from '@nivo/tooltip'\nimport { LineSeries, PointTooltipProps } from './types'\n\nexport const NonMemoizedPointTooltip = <Series extends LineSeries>({\n    point,\n}: PointTooltipProps<Series>) => {\n    return (\n        <BasicTooltip\n            id={\n                <span>\n                    x: <strong>{point.data.xFormatted}</strong>, y:{' '}\n                    <strong>{point.data.yFormatted}</strong>\n                </span>\n            }\n            enableChip={true}\n            color={point.seriesColor}\n        />\n    )\n}\n\nexport const PointTooltip = memo(NonMemoizedPointTooltip)\n", "import { defaultAxisProps } from '@nivo/axes'\nimport {\n    CommonLineProps,\n    LineSvgPropsWithDefaults,\n    LineCanvasPropsWithDefaults,\n    DefaultSeries,\n    LineLayerId,\n} from './types'\nimport { PointTooltip } from './PointTooltip'\nimport { SliceTooltip } from './SliceTooltip'\n\nexport const commonDefaultProps: Omit<\n    CommonLineProps<DefaultSeries>,\n    | 'data'\n    | 'xFormat'\n    | 'yFormat'\n    | 'layers'\n    | 'width'\n    | 'height'\n    | 'margin'\n    | 'theme'\n    | 'pointSymbol'\n    | 'gridXValues'\n    | 'gridYValues'\n    | 'onMouseEnter'\n    | 'onMouseMove'\n    | 'onMouseLeave'\n    | 'onMouseDown'\n    | 'onMouseUp'\n    | 'onClick'\n    | 'onDoubleClick'\n    | 'onTouchStart'\n    | 'onTouchMove'\n    | 'onTouchEnd'\n> & {\n    layers: LineLayerId[]\n} = {\n    xScale: {\n        type: 'point',\n    },\n    yScale: {\n        type: 'linear',\n        min: 0,\n        max: 'auto',\n    },\n    curve: 'linear',\n    colors: { scheme: 'nivo' },\n    lineWidth: 2,\n    layers: [\n        'grid',\n        'markers',\n        'axes',\n        'areas',\n        'crosshair',\n        'lines',\n        'points',\n        'slices',\n        'mesh',\n        'legends',\n    ],\n    enablePoints: true,\n    pointSize: 6,\n    pointColor: { from: 'series.color' },\n    pointBorderWidth: 0,\n    pointBorderColor: { theme: 'background' },\n    enableArea: false,\n    areaBaselineValue: 0,\n    areaOpacity: 0.2,\n    enableGridX: true,\n    enableGridY: true,\n    legends: [],\n    isInteractive: true,\n    tooltip: PointTooltip,\n    sliceTooltip: SliceTooltip,\n    debugMesh: false,\n    renderWrapper: true,\n}\n\nexport const svgDefaultProps: Omit<\n    LineSvgPropsWithDefaults<DefaultSeries>,\n    'data' | 'width' | 'height' | 'margin' | 'theme'\n> = {\n    ...commonDefaultProps,\n    defs: [],\n    fill: [],\n    enablePointLabel: false,\n    pointLabel: 'data.yFormatted',\n    areaBlendMode: 'normal',\n    axisTop: null,\n    axisRight: null,\n    axisBottom: defaultAxisProps,\n    axisLeft: defaultAxisProps,\n    useMesh: false,\n    enableSlices: false,\n    debugSlices: false,\n    enableCrosshair: true,\n    crosshairType: 'bottom-left',\n    enableTouchCrosshair: false,\n    initialHiddenIds: [],\n    animate: true,\n    motionConfig: 'gentle',\n    role: 'img',\n    isFocusable: false,\n}\n\nexport const canvasDefaultProps: Omit<\n    LineCanvasPropsWithDefaults<DefaultSeries>,\n    'data' | 'width' | 'height' | 'margin' | 'theme'\n> = {\n    ...commonDefaultProps,\n    pixelRatio: typeof window !== 'undefined' ? (window.devicePixelRatio ?? 1) : 1,\n    axisTop: null,\n    axisRight: null,\n    axisBottom: defaultAxisProps,\n    axisLeft: defaultAxisProps,\n}\n", "import { memo } from 'react'\nimport { useTheme } from '@nivo/theming'\nimport { Chip, TableTooltip } from '@nivo/tooltip'\nimport { LineSeries, SliceTooltipProps } from './types'\n\nexport const NonMemoizedSliceTooltip = <Series extends LineSeries>({\n    slice,\n    axis,\n}: SliceTooltipProps<Series>) => {\n    const theme = useTheme()\n    const otherAxis = axis === 'x' ? 'y' : 'x'\n\n    return (\n        <TableTooltip\n            rows={slice.points.map(point => [\n                <Chip key=\"chip\" color={point.seriesColor} style={theme.tooltip.chip} />,\n                point.seriesId,\n                <span key=\"value\" style={theme.tooltip.tableCellValue}>\n                    {point.data[`${otherAxis}Formatted`]}\n                </span>,\n            ])}\n        />\n    )\n}\n\nexport const SliceTooltip = memo(NonMemoizedSliceTooltip)\n", "import { useCallback, useMemo, useState } from 'react'\nimport { area, line } from 'd3-shape'\nimport uniqueId from 'lodash/uniqueId.js'\nimport { curveFromProp, useValueFormatter } from '@nivo/core'\nimport { useTheme } from '@nivo/theming'\nimport {\n    useOrdinalColorScale,\n    useInheritedColor,\n    OrdinalColorScaleConfig,\n    InheritedColorConfig,\n} from '@nivo/colors'\nimport { computeXYScalesForSeries } from '@nivo/scales'\nimport { commonDefaultProps, svgDefaultProps } from './defaults'\nimport {\n    LineSeries,\n    CommonLineProps,\n    DataProps,\n    InferX,\n    InferY,\n    InferSeriesId,\n    LineSvgProps,\n    LineGenerator,\n    AreaGenerator,\n    AllowedValue,\n    ComputedSeries,\n    Point,\n    SliceData,\n    PointColorContext,\n} from './types'\n\nexport function useLineGenerator(curve: CommonLineProps<LineSeries>['curve']): LineGenerator {\n    return useMemo(() => {\n        return line<{\n            x: number\n            y: number\n        }>()\n            .defined(d => d.x !== null && d.y !== null)\n            .x(d => d.x)\n            .y(d => d.y)\n            .curve(curveFromProp(curve))\n    }, [curve])\n}\n\nexport function useAreaGenerator<Y extends AllowedValue>({\n    curve,\n    yScale,\n    areaBaselineValue,\n}: {\n    curve: CommonLineProps<LineSeries>['curve']\n    yScale: (y: Y) => number\n    areaBaselineValue: Y\n}): AreaGenerator {\n    return useMemo(() => {\n        return area<{\n            x: number\n            y: number\n        }>()\n            .defined(d => d.x !== null && d.y !== null)\n            .x(d => d.x)\n            .y1(d => d.y)\n            .curve(curveFromProp(curve))\n            .y0(yScale(areaBaselineValue))\n    }, [curve, yScale, areaBaselineValue])\n}\n\nfunction usePoints<Series extends LineSeries>({\n    series,\n    getPointColor,\n    getPointBorderColor,\n    formatX,\n    formatY,\n}: {\n    series: ComputedSeries<Series>[]\n    getPointColor: (context: PointColorContext<Series>) => string\n    getPointBorderColor: (point: Omit<Point<Series>, 'borderColor'>) => string\n    formatX: (x: InferX<Series>) => string\n    formatY: (y: InferY<Series>) => string\n}) {\n    return useMemo(() => {\n        return series.reduce((acc, seriesItem, seriesIndex) => {\n            return [\n                ...acc,\n                ...seriesItem.data\n                    .filter(datum => datum.position.x !== null && datum.position.y !== null)\n                    .map((datum, indexInSeries) => {\n                        const point: Omit<Point<Series>, 'color' | 'borderColor'> & {\n                            color?: string\n                            borderColor?: string\n                        } = {\n                            id: `${seriesItem.id}.${indexInSeries}`,\n                            indexInSeries,\n                            absIndex: acc.length + indexInSeries,\n                            seriesIndex,\n                            seriesId: seriesItem.id,\n                            seriesColor: seriesItem.color,\n                            x: datum.position.x,\n                            y: datum.position.y,\n                            data: {\n                                ...datum.data,\n                                xFormatted: formatX(datum.data.x as InferX<Series>),\n                                yFormatted: formatY(datum.data.y as InferY<Series>),\n                            },\n                        }\n                        point.color = getPointColor({\n                            series: seriesItem,\n                            point: point as Omit<Point<Series>, 'color' | 'borderColor'>,\n                        })\n                        point.borderColor = getPointBorderColor(\n                            point as Omit<Point<Series>, 'borderColor'>\n                        )\n\n                        return point as Point<Series>\n                    }),\n            ]\n        }, [] as Point<Series>[])\n    }, [series, getPointColor, getPointBorderColor, formatX, formatY])\n}\n\nexport const useSlices = <Series extends LineSeries>({\n    componentId,\n    enableSlices,\n    points,\n    width,\n    height,\n}: {\n    componentId: string\n    enableSlices: Exclude<LineSvgProps<Series>['enableSlices'], undefined>\n    points: Point<Series>[]\n    width: number\n    height: number\n}) => {\n    return useMemo(() => {\n        if (enableSlices === 'x') {\n            const map = new Map()\n            points.forEach(point => {\n                if (point.data.x === null || point.data.y === null) return\n                if (!map.has(point.x)) map.set(point.x, [point])\n                else map.get(point.x).push(point)\n            })\n\n            return Array.from(map.entries())\n                .sort((a, b) => a[0] - b[0])\n                .map(([x, slicePoints], i, slices) => {\n                    const prevSlice = slices[i - 1]\n                    const nextSlice = slices[i + 1]\n\n                    let x0\n                    if (!prevSlice) x0 = x\n                    else x0 = x - (x - prevSlice[0]) / 2\n\n                    let sliceWidth\n                    if (!nextSlice) sliceWidth = width - x0\n                    else sliceWidth = x - x0 + (nextSlice[0] - x) / 2\n\n                    return {\n                        id: `slice:${componentId}:${x}`,\n                        x0,\n                        x,\n                        y0: 0,\n                        y: 0,\n                        width: sliceWidth,\n                        height,\n                        points: slicePoints.reverse(),\n                    } as SliceData<Series>\n                })\n        } else if (enableSlices === 'y') {\n            const map = new Map()\n            points.forEach(point => {\n                if (point.data.x === null || point.data.y === null) return\n                if (!map.has(point.y)) map.set(point.y, [point])\n                else map.get(point.y).push(point)\n            })\n\n            return Array.from(map.entries())\n                .sort((a, b) => a[0] - b[0])\n                .map(([y, slicePoints], i, slices) => {\n                    const prevSlice = slices[i - 1]\n                    const nextSlice = slices[i + 1]\n\n                    let y0\n                    if (!prevSlice) y0 = y\n                    else y0 = y - (y - prevSlice[0]) / 2\n\n                    let sliceHeight\n                    if (!nextSlice) sliceHeight = height - y0\n                    else sliceHeight = y - y0 + (nextSlice[0] - y) / 2\n\n                    return {\n                        id: y,\n                        x0: 0,\n                        x: 0,\n                        y0,\n                        y,\n                        width,\n                        height: sliceHeight,\n                        points: slicePoints.reverse(),\n                    } as SliceData<Series>\n                })\n        }\n\n        return []\n    }, [componentId, enableSlices, height, points, width])\n}\n\nexport const LINE_UNIQUE_ID_PREFIX = 'line'\n\nexport const useLine = <Series extends LineSeries>({\n    data,\n    xScale: xScaleSpec = commonDefaultProps.xScale,\n    xFormat,\n    yScale: yScaleSpec = commonDefaultProps.yScale,\n    yFormat,\n    width,\n    height,\n    colors = commonDefaultProps.colors as OrdinalColorScaleConfig<Series>,\n    curve = commonDefaultProps.curve,\n    areaBaselineValue = commonDefaultProps.areaBaselineValue as InferY<Series>,\n    pointColor = commonDefaultProps.pointColor as InheritedColorConfig<PointColorContext<Series>>,\n    pointBorderColor = commonDefaultProps.pointBorderColor as InheritedColorConfig<\n        Omit<Point<Series>, 'borderColor'>\n    >,\n    enableSlices = svgDefaultProps.enableSlices as Exclude<\n        LineSvgProps<Series>['enableSlices'],\n        undefined\n    >,\n    initialHiddenIds = svgDefaultProps.initialHiddenIds as InferSeriesId<Series>[],\n}: DataProps<Series> &\n    Pick<\n        CommonLineProps<Series>,\n        | 'xScale'\n        | 'yScale'\n        | 'colors'\n        | 'curve'\n        | 'areaBaselineValue'\n        | 'pointColor'\n        | 'pointBorderColor'\n    > & {\n        xFormat?: CommonLineProps<Series>['xFormat']\n        yFormat?: CommonLineProps<Series>['yFormat']\n    } & Pick<LineSvgProps<Series>, 'enableSlices' | 'initialHiddenIds'> & {\n        width: number\n        height: number\n    }): {\n    legendData: {\n        id: InferSeriesId<Series>\n        label: string\n        color: string\n        hidden: boolean\n    }[]\n    toggleSeries: (id: InferSeriesId<Series>) => void\n    lineGenerator: LineGenerator\n    areaGenerator: AreaGenerator\n    getColor: (series: Series) => string\n    series: ComputedSeries<Series>[]\n    xScale: (x: InferX<Series>) => number\n    yScale: (y: InferY<Series>) => number\n    slices: SliceData<Series>[]\n    points: Point<Series>[]\n} => {\n    const [componentId] = useState(uniqueId(LINE_UNIQUE_ID_PREFIX))\n    const formatX = useValueFormatter(xFormat)\n    const formatY = useValueFormatter(yFormat)\n    const getColor = useOrdinalColorScale(colors, 'id')\n    const theme = useTheme()\n    const getPointColor = useInheritedColor(pointColor, theme)\n    const getPointBorderColor = useInheritedColor(pointBorderColor, theme)\n    const [hiddenIds, setHiddenIds] = useState(initialHiddenIds ?? [])\n\n    const {\n        xScale,\n        yScale,\n        series: rawSeries,\n    } = useMemo(\n        () =>\n            computeXYScalesForSeries<Series, Series['data'][number]>(\n                data.filter(item => hiddenIds.indexOf(item.id as InferSeriesId<Series>) === -1),\n                xScaleSpec,\n                yScaleSpec,\n                width,\n                height\n            ),\n        [data, hiddenIds, xScaleSpec, yScaleSpec, width, height]\n    )\n\n    const { legendData, series } = useMemo(() => {\n        const dataWithColor = data.map(seriesItem => ({\n            id: seriesItem.id as InferSeriesId<Series>,\n            label: `${seriesItem.id}`,\n            color: getColor(seriesItem),\n        }))\n\n        const series = dataWithColor\n            .map(datum => ({\n                ...rawSeries.find(seriesItem => seriesItem.id === datum.id)!,\n                color: datum.color,\n            }))\n            .filter(item => Boolean(item.id)) as unknown as ComputedSeries<Series>[]\n\n        const legendData = dataWithColor\n            .map(item => ({\n                ...item,\n                hidden: !series.find(seriesItem => seriesItem.id === item.id),\n            }))\n            .reverse()\n\n        return { legendData, series }\n    }, [data, rawSeries, getColor])\n\n    const toggleSeries = useCallback((id: InferSeriesId<Series>) => {\n        setHiddenIds(state =>\n            state.indexOf(id) > -1 ? state.filter(item => item !== id) : [...state, id]\n        )\n    }, [])\n\n    const points = usePoints<Series>({\n        series,\n        getPointColor,\n        getPointBorderColor,\n        formatX,\n        formatY,\n    })\n\n    const slices = useSlices<Series>({\n        componentId,\n        enableSlices,\n        points,\n        width,\n        height,\n    })\n\n    const lineGenerator = useLineGenerator(curve)\n    const areaGenerator = useAreaGenerator<InferY<Series>>({\n        curve,\n        yScale: yScale as (y: InferY<Series>) => number,\n        areaBaselineValue,\n    })\n\n    return {\n        legendData,\n        toggleSeries,\n        lineGenerator,\n        areaGenerator,\n        getColor,\n        series,\n        xScale: xScale as (x: InferX<Series>) => number,\n        yScale: yScale as (y: InferY<Series>) => number,\n        slices,\n        points,\n    }\n}\n", "import { memo } from 'react'\nimport { useSpring, animated } from '@react-spring/web'\nimport { CssMixBlendMode, useAnimatedPath, useMotionConfig } from '@nivo/core'\nimport { LineSeries, ComputedSeries, AreaGenerator } from './types'\n\nconst AreaPath = ({\n    areaBlendMode,\n    areaOpacity,\n    color,\n    fill,\n    path,\n}: {\n    areaBlendMode: CssMixBlendMode\n    areaOpacity: number\n    color: string\n    fill?: string\n    path: string\n}) => {\n    const { animate, config: springConfig } = useMotionConfig()\n\n    const animatedPath = useAnimatedPath(path)\n    const animatedProps = useSpring({\n        color,\n        config: springConfig,\n        immediate: !animate,\n    })\n\n    return (\n        <animated.path\n            d={animatedPath}\n            fill={fill ? fill : animatedProps.color}\n            fillOpacity={areaOpacity}\n            strokeWidth={0}\n            style={{\n                mixBlendMode: areaBlendMode,\n            }}\n        />\n    )\n}\n\nconst NonMemoizedAreas = <Series extends LineSeries>({\n    areaGenerator,\n    areaOpacity,\n    areaBlendMode,\n    series,\n}: {\n    areaGenerator: AreaGenerator\n    areaOpacity: number\n    areaBlendMode: CssMixBlendMode\n    series: readonly ComputedSeries<Series>[]\n}) => {\n    const reversedSeries = series.slice(0).reverse()\n\n    return (\n        <g>\n            {reversedSeries.map(seriesItem => (\n                <AreaPath\n                    key={`${seriesItem.id}`}\n                    path={areaGenerator(seriesItem.data.map(d => d.position))!}\n                    {...{ areaOpacity, areaBlendMode, ...seriesItem }}\n                />\n            ))}\n        </g>\n    )\n}\n\nexport const Areas = memo(NonMemoizedAreas) as typeof NonMemoizedAreas\n", "import { memo, useMemo } from 'react'\nimport { animated } from '@react-spring/web'\nimport { useAnimatedPath } from '@nivo/core'\nimport { LineGenerator } from './types'\n\nexport const NonMemoizedLinesItem = ({\n    lineGenerator,\n    points,\n    color,\n    thickness,\n}: {\n    lineGenerator: LineGenerator\n    points: { x: number; y: number }[]\n    color: string\n    thickness: number\n}) => {\n    const path = useMemo(() => lineGenerator(points), [lineGenerator, points])\n    const animatedPath = useAnimatedPath(path!)\n\n    return <animated.path d={animatedPath} fill=\"none\" strokeWidth={thickness} stroke={color} />\n}\n\nexport const LinesItem = memo(NonMemoizedLinesItem) as typeof NonMemoizedLinesItem\n", "import { memo } from 'react'\nimport { LineSeries, ComputedSeries, LineGenerator } from './types'\nimport { LinesItem } from './LinesItem'\n\nexport const NonMemoizedLines = <Series extends LineSeries>({\n    series,\n    lineGenerator,\n    lineWidth,\n}: {\n    series: readonly ComputedSeries<Series>[]\n    lineGenerator: LineGenerator\n    lineWidth: number\n}) => {\n    return (\n        <>\n            {series\n                .slice(0)\n                .reverse()\n                .map(({ id, data, color }) => (\n                    <LinesItem\n                        key={id}\n                        points={data.map(d => d.position)}\n                        lineGenerator={lineGenerator}\n                        color={color}\n                        thickness={lineWidth}\n                    />\n                ))}\n        </>\n    )\n}\n\nexport const Lines = memo(NonMemoizedLines) as typeof NonMemoizedLines\n", "import { createElement, memo, useCallback, MouseEvent, TouchEvent } from 'react'\nimport { useTooltip } from '@nivo/tooltip'\nimport { LineSeries, SliceData, CommonLineProps, LineSvgProps } from './types'\n\nexport const NonMemoizedSlicesItem = <Series extends LineSeries>({\n    slice,\n    slices,\n    axis,\n    debug,\n    tooltip,\n    isCurrent,\n    setCurrent,\n    onMouseEnter,\n    onMouseMove,\n    onMouseLeave,\n    onMouseDown,\n    onMouseUp,\n    onClick,\n    onDoubleClick,\n    onTouchStart,\n    onTouchMove,\n    onTouchEnd,\n}: {\n    slice: SliceData<Series>\n    slices: readonly SliceData<Series>[]\n    axis: Exclude<LineSvgProps<Series>['enableSlices'], undefined | false>\n    debug: boolean\n    tooltip: CommonLineProps<Series>['sliceTooltip']\n    isCurrent: boolean\n    setCurrent: (slice: SliceData<Series> | null) => void\n    onMouseEnter?: CommonLineProps<Series>['onMouseEnter']\n    onMouseMove?: CommonLineProps<Series>['onMouseMove']\n    onMouseLeave?: CommonLineProps<Series>['onMouseLeave']\n    onMouseDown?: CommonLineProps<Series>['onMouseDown']\n    onMouseUp?: CommonLineProps<Series>['onMouseUp']\n    onClick?: CommonLineProps<Series>['onClick']\n    onDoubleClick?: CommonLineProps<Series>['onDoubleClick']\n    onTouchStart?: CommonLineProps<Series>['onTouchStart']\n    onTouchMove?: CommonLineProps<Series>['onTouchMove']\n    onTouchEnd?: CommonLineProps<Series>['onTouchEnd']\n}) => {\n    const { showTooltipFromEvent, hideTooltip } = useTooltip()\n\n    const handleMouseEnter = useCallback(\n        (event: MouseEvent<SVGRectElement>) => {\n            showTooltipFromEvent(createElement(tooltip, { slice, axis }), event, 'right')\n            setCurrent(slice)\n            onMouseEnter?.(slice, event)\n        },\n        [showTooltipFromEvent, tooltip, slice, axis, setCurrent, onMouseEnter]\n    )\n\n    const handleMouseMove = useCallback(\n        (event: MouseEvent<SVGRectElement>) => {\n            showTooltipFromEvent(createElement(tooltip, { slice, axis }), event, 'right')\n            onMouseMove?.(slice, event)\n        },\n        [showTooltipFromEvent, tooltip, slice, axis, onMouseMove]\n    )\n\n    const handleMouseLeave = useCallback(\n        (event: MouseEvent<SVGRectElement>) => {\n            hideTooltip()\n            setCurrent(null)\n            onMouseLeave?.(slice, event)\n        },\n        [hideTooltip, setCurrent, onMouseLeave, slice]\n    )\n\n    const handleMouseDown = useCallback(\n        (event: MouseEvent<SVGRectElement>) => {\n            onMouseDown?.(slice, event)\n        },\n        [slice, onMouseDown]\n    )\n\n    const handleMouseUp = useCallback(\n        (event: MouseEvent<SVGRectElement>) => {\n            onMouseUp?.(slice, event)\n        },\n        [slice, onMouseUp]\n    )\n\n    const handleClick = useCallback(\n        (event: MouseEvent<SVGRectElement>) => {\n            onClick?.(slice, event)\n        },\n        [slice, onClick]\n    )\n\n    const handleDoubleClick = useCallback(\n        (event: MouseEvent<SVGRectElement>) => {\n            onDoubleClick?.(slice, event)\n        },\n        [slice, onDoubleClick]\n    )\n\n    const handeOnTouchStart = useCallback(\n        (event: TouchEvent<SVGRectElement>) => {\n            showTooltipFromEvent(createElement(tooltip, { slice, axis }), event, 'right')\n            setCurrent(slice)\n            onTouchStart?.(slice, event)\n        },\n        [axis, onTouchStart, setCurrent, showTooltipFromEvent, slice, tooltip]\n    )\n\n    const handeOnTouchMove = useCallback(\n        (event: TouchEvent<SVGRectElement>) => {\n            // This event will be locked to the element that was touched originally\n            // We find the element that is currently being \"hovered over\" by getting the element at the touch point\n            const touchPoint = event.touches[0]\n            const touchingElement = document.elementFromPoint(\n                touchPoint.clientX,\n                touchPoint.clientY\n            )\n            // Is this a nivo ref?\n            const touchingSliceId = touchingElement?.getAttribute('data-ref')\n            if (touchingSliceId) {\n                // Is this a slice for this graph?\n                const slice = slices.find(slice => slice.id === touchingSliceId)\n                if (slice) {\n                    showTooltipFromEvent(createElement(tooltip, { slice, axis }), event, 'right')\n                    setCurrent(slice)\n                }\n            }\n\n            // Note here, this will pass the original slice, not the one we found\n            // But this can be found with document.elementFromPoint()\n            onTouchMove?.(slice, event)\n        },\n        [axis, onTouchMove, setCurrent, showTooltipFromEvent, slice, slices, tooltip]\n    )\n\n    const handleOnTouchEnd = useCallback(\n        (event: TouchEvent<SVGRectElement>) => {\n            hideTooltip()\n            setCurrent(null)\n            onTouchEnd?.(slice, event)\n        },\n        [hideTooltip, setCurrent, onTouchEnd, slice]\n    )\n\n    return (\n        <rect\n            x={slice.x0}\n            y={slice.y0}\n            width={slice.width}\n            height={slice.height}\n            stroke=\"red\"\n            strokeWidth={debug ? 1 : 0}\n            strokeOpacity={0.75}\n            fill=\"red\"\n            fillOpacity={isCurrent && debug ? 0.35 : 0}\n            onMouseEnter={handleMouseEnter}\n            onMouseMove={handleMouseMove}\n            onMouseLeave={handleMouseLeave}\n            onMouseDown={handleMouseDown}\n            onMouseUp={handleMouseUp}\n            onClick={handleClick}\n            onDoubleClick={handleDoubleClick}\n            onTouchStart={handeOnTouchStart}\n            onTouchMove={handeOnTouchMove}\n            onTouchEnd={handleOnTouchEnd}\n            data-ref={slice.id}\n        />\n    )\n}\n\nexport const SlicesItem = memo(NonMemoizedSlicesItem) as typeof NonMemoizedSlicesItem\n", "import { memo } from 'react'\nimport { SlicesItem } from './SlicesItem'\nimport { LineSeries, SliceData, CommonLineProps, LineSvgProps } from './types'\n\nexport const NonMemoizedSlices = <Series extends LineSeries>({\n    slices,\n    axis,\n    debug,\n    tooltip,\n    current,\n    setCurrent,\n    onMouseEnter,\n    onMouseMove,\n    onMouseLeave,\n    onMouseDown,\n    onMouseUp,\n    onClick,\n    onDoubleClick,\n    onTouchStart,\n    onTouchMove,\n    onTouchEnd,\n}: {\n    slices: readonly SliceData<Series>[]\n    axis: Exclude<LineSvgProps<Series>['enableSlices'], undefined | false>\n    debug: boolean\n    tooltip: CommonLineProps<Series>['sliceTooltip']\n    current: SliceData<Series> | null\n    setCurrent: (slice: SliceData<Series> | null) => void\n    onMouseEnter?: CommonLineProps<Series>['onMouseEnter']\n    onMouseMove?: CommonLineProps<Series>['onMouseMove']\n    onMouseLeave?: CommonLineProps<Series>['onMouseLeave']\n    onMouseDown?: CommonLineProps<Series>['onMouseDown']\n    onMouseUp?: CommonLineProps<Series>['onMouseUp']\n    onClick?: CommonLineProps<Series>['onClick']\n    onDoubleClick?: CommonLineProps<Series>['onDoubleClick']\n    onTouchStart?: CommonLineProps<Series>['onTouchStart']\n    onTouchMove?: CommonLineProps<Series>['onTouchMove']\n    onTouchEnd?: CommonLineProps<Series>['onTouchEnd']\n}) => {\n    return (\n        <>\n            {slices.map(slice => (\n                <SlicesItem<Series>\n                    key={slice.id}\n                    slice={slice}\n                    slices={slices}\n                    axis={axis}\n                    debug={debug}\n                    tooltip={tooltip}\n                    setCurrent={setCurrent}\n                    isCurrent={current !== null && current.id === slice.id}\n                    onMouseEnter={onMouseEnter}\n                    onMouseMove={onMouseMove}\n                    onMouseLeave={onMouseLeave}\n                    onMouseDown={onMouseDown}\n                    onMouseUp={onMouseUp}\n                    onClick={onClick}\n                    onDoubleClick={onDoubleClick}\n                    onTouchStart={onTouchStart}\n                    onTouchMove={onTouchMove}\n                    onTouchEnd={onTouchEnd}\n                />\n            ))}\n        </>\n    )\n}\n\nexport const Slices = memo(NonMemoizedSlices) as typeof NonMemoizedSlices\n", "import { createElement, memo } from 'react'\n// @ts-expect-error no types\nimport { getLabelGenerator } from '@nivo/core'\nimport { DotsItem, Margin } from '@nivo/core'\nimport { useTooltip } from '@nivo/tooltip'\nimport { LineSeries, LineSvgPropsWithDefaults, Point } from './types'\n\nconst NonMemoizedPoints = <Series extends LineSeries>({\n    points,\n    symbol,\n    size,\n    borderWidth,\n    enableLabel,\n    label,\n    labelYOffset,\n    isFocusable,\n    setCurrentPoint,\n    tooltip,\n    margin,\n    ariaLabel,\n    ariaLabelledBy,\n    ariaDescribedBy,\n    ariaHidden,\n    ariaDisabled,\n}: {\n    points: readonly Point<Series>[]\n    symbol: LineSvgPropsWithDefaults<Series>['pointSymbol']\n    size: number\n    borderWidth: LineSvgPropsWithDefaults<Series>['pointBorderWidth']\n    enableLabel: LineSvgPropsWithDefaults<Series>['enablePointLabel']\n    label: LineSvgPropsWithDefaults<Series>['pointLabel']\n    labelYOffset: LineSvgPropsWithDefaults<Series>['pointLabelYOffset']\n    isFocusable: LineSvgPropsWithDefaults<Series>['isFocusable']\n    setCurrentPoint: (point: Point<Series> | null) => void\n    tooltip: LineSvgPropsWithDefaults<Series>['tooltip']\n    margin: Margin\n    ariaLabel: LineSvgPropsWithDefaults<Series>['pointAriaLabel']\n    ariaLabelledBy: LineSvgPropsWithDefaults<Series>['pointAriaLabelledBy']\n    ariaDescribedBy: LineSvgPropsWithDefaults<Series>['pointAriaDescribedBy']\n    ariaHidden: LineSvgPropsWithDefaults<Series>['pointAriaHidden']\n    ariaDisabled: LineSvgPropsWithDefaults<Series>['pointAriaDisabled']\n}) => {\n    const getLabel = getLabelGenerator(label)\n\n    const { showTooltipAt, hideTooltip } = useTooltip()\n\n    // We sort the points so that the lower series are drawn on top of the higher ones.\n    const mappedPoints = points\n        .slice(0)\n        .sort((a, b) => a.indexInSeries - b.indexInSeries)\n        .sort((a, b) => b.seriesIndex - a.seriesIndex)\n        .map(point => {\n            return {\n                id: point.id,\n                x: point.x,\n                y: point.y,\n                datum: point.data,\n                fill: point.color,\n                stroke: point.borderColor,\n                label: enableLabel ? getLabel(point) : null,\n                ariaLabel: ariaLabel ? ariaLabel(point) : undefined,\n                ariaLabelledBy: ariaLabelledBy ? ariaLabelledBy(point) : undefined,\n                ariaDescribedBy: ariaDescribedBy ? ariaDescribedBy(point) : undefined,\n                ariaHidden: ariaHidden ? ariaHidden(point) : undefined,\n                ariaDisabled: ariaDisabled ? ariaDisabled(point) : undefined,\n                onFocus: isFocusable\n                    ? () => {\n                          setCurrentPoint(point)\n                          showTooltipAt(\n                              createElement(tooltip, { point }),\n                              [margin.left + point.x, margin.top + point.y],\n                              'top'\n                          )\n                      }\n                    : undefined,\n                onBlur: isFocusable\n                    ? () => {\n                          setCurrentPoint(null)\n                          hideTooltip()\n                      }\n                    : undefined,\n            }\n        })\n\n    return (\n        <g>\n            {mappedPoints.map(point => (\n                <DotsItem\n                    key={point.id}\n                    x={point.x}\n                    y={point.y}\n                    datum={point.datum}\n                    symbol={symbol as any}\n                    size={size}\n                    color={point.fill}\n                    borderWidth={borderWidth}\n                    borderColor={point.stroke}\n                    label={point.label}\n                    labelYOffset={labelYOffset}\n                    ariaLabel={point.ariaLabel}\n                    ariaLabelledBy={point.ariaLabelledBy}\n                    ariaDescribedBy={point.ariaDescribedBy}\n                    ariaHidden={point.ariaHidden}\n                    ariaDisabled={point.ariaDisabled}\n                    isFocusable={isFocusable}\n                    onFocus={point.onFocus}\n                    onBlur={point.onBlur}\n                    testId={`line.point.${point.id}`}\n                />\n            ))}\n        </g>\n    )\n}\n\nexport const Points = memo(NonMemoizedPoints) as typeof NonMemoizedPoints\n", "import { createElement, memo, useCallback, MouseEvent, TouchEvent } from 'react'\nimport { Margin } from '@nivo/core'\nimport { useTooltip } from '@nivo/tooltip'\nimport { Mesh as BaseMesh } from '@nivo/voronoi'\nimport { LineSeries, Point, LineSvgProps, LineSvgPropsWithDefaults } from './types'\n\nconst NonMemoizedMesh = <Series extends LineSeries>({\n    points,\n    width,\n    height,\n    margin,\n    setCurrent,\n    onMouseEnter,\n    onMouseMove,\n    onMouseLeave,\n    onMouseDown,\n    onMouseUp,\n    onClick,\n    onDoubleClick,\n    onTouchStart,\n    onTouchMove,\n    onTouchEnd,\n    tooltip,\n    debug,\n    enableTouchCrosshair,\n}: {\n    points: Point<Series>[]\n    width: number\n    height: number\n    margin: Margin\n    setCurrent: (point: Point<Series> | null) => void\n    onMouseEnter?: LineSvgProps<Series>['onMouseEnter']\n    onMouseMove?: LineSvgProps<Series>['onMouseMove']\n    onMouseLeave?: LineSvgProps<Series>['onMouseLeave']\n    onMouseDown?: LineSvgProps<Series>['onMouseDown']\n    onMouseUp?: LineSvgProps<Series>['onMouseUp']\n    onClick?: LineSvgProps<Series>['onClick']\n    onDoubleClick?: LineSvgProps<Series>['onDoubleClick']\n    onTouchStart?: LineSvgProps<Series>['onTouchStart']\n    onTouchMove?: LineSvgProps<Series>['onTouchMove']\n    onTouchEnd?: LineSvgProps<Series>['onTouchEnd']\n    tooltip: LineSvgPropsWithDefaults<Series>['tooltip']\n    debug: boolean\n    enableTouchCrosshair: LineSvgPropsWithDefaults<Series>['enableTouchCrosshair']\n}) => {\n    const { showTooltipAt, hideTooltip } = useTooltip()\n\n    const handleMouseEnter = useCallback(\n        (point: Point<Series>, event: MouseEvent) => {\n            showTooltipAt(\n                createElement(tooltip, { point }),\n                [point.x + margin.left, point.y + margin.top],\n                'top'\n            )\n            onMouseEnter?.(point, event)\n        },\n        [showTooltipAt, tooltip, onMouseEnter, margin]\n    )\n\n    const handleMouseMove = useCallback(\n        (point: Point<Series>, event: MouseEvent) => {\n            showTooltipAt(\n                createElement(tooltip, { point }),\n                [point.x + margin.left, point.y + margin.top],\n                'top'\n            )\n            onMouseMove?.(point, event)\n        },\n        [showTooltipAt, tooltip, margin.left, margin.top, onMouseMove]\n    )\n\n    const handleMouseLeave = useCallback(\n        (point: Point<Series>, event: MouseEvent) => {\n            hideTooltip()\n            onMouseLeave?.(point, event)\n        },\n        [hideTooltip, onMouseLeave]\n    )\n\n    const handleMouseDown = useCallback(\n        (point: Point<Series>, event: MouseEvent) => {\n            onMouseDown?.(point, event)\n        },\n        [onMouseDown]\n    )\n\n    const handleMouseUp = useCallback(\n        (point: Point<Series>, event: MouseEvent) => {\n            onMouseUp?.(point, event)\n        },\n        [onMouseUp]\n    )\n\n    const handleClick = useCallback(\n        (point: Point<Series>, event: MouseEvent) => {\n            onClick?.(point, event)\n        },\n        [onClick]\n    )\n\n    const handleDoubleClick = useCallback(\n        (point: Point<Series>, event: MouseEvent) => {\n            onDoubleClick?.(point, event)\n        },\n        [onDoubleClick]\n    )\n\n    const handleTouchStart = useCallback(\n        (point: Point<Series>, event: TouchEvent) => {\n            showTooltipAt(\n                createElement(tooltip, { point }),\n                [point.x + margin.left, point.y + margin.top],\n                'top'\n            )\n            onTouchStart?.(point, event)\n        },\n        [margin.left, margin.top, onTouchStart, showTooltipAt, tooltip]\n    )\n\n    const handleTouchMove = useCallback(\n        (point: Point<Series>, event: TouchEvent) => {\n            showTooltipAt(\n                createElement(tooltip, { point }),\n                [point.x + margin.left, point.y + margin.top],\n                'top'\n            )\n            onTouchMove?.(point, event)\n        },\n        [margin.left, margin.top, onTouchMove, showTooltipAt, tooltip]\n    )\n\n    const handleTouchEnd = useCallback(\n        (point: Point<Series>, event: TouchEvent) => {\n            hideTooltip()\n            onTouchEnd?.(point, event)\n        },\n        [onTouchEnd, hideTooltip]\n    )\n\n    return (\n        <BaseMesh<Point<Series>>\n            nodes={points}\n            width={width}\n            height={height}\n            setCurrent={setCurrent}\n            onMouseEnter={handleMouseEnter}\n            onMouseMove={handleMouseMove}\n            onMouseLeave={handleMouseLeave}\n            onMouseDown={handleMouseDown}\n            onMouseUp={handleMouseUp}\n            onClick={handleClick}\n            onDoubleClick={handleDoubleClick}\n            onTouchStart={handleTouchStart}\n            onTouchMove={handleTouchMove}\n            onTouchEnd={handleTouchEnd}\n            enableTouchCrosshair={enableTouchCrosshair}\n            debug={debug}\n        />\n    )\n}\n\nexport const Mesh = memo(NonMemoizedMesh) as typeof NonMemoizedMesh\n", "import { Fragment, ReactNode, useState, forwardRef, Ref, ReactElement } from 'react'\nimport {\n    // @ts-expect-error no types\n    bindDefs,\n    useDimensions,\n    SvgWrapper,\n    CartesianMarkers,\n    Container,\n    LineCurveFactoryId,\n    WithChartRef,\n} from '@nivo/core'\nimport { InheritedColorConfig, OrdinalColorScaleConfig } from '@nivo/colors'\nimport { Axes, Grid } from '@nivo/axes'\nimport { BoxLegendSvg } from '@nivo/legends'\nimport { Crosshair, CrosshairType } from '@nivo/tooltip'\nimport { AnyScale } from '@nivo/scales'\nimport { useLine } from './hooks'\nimport { Areas } from './Areas'\nimport { Lines } from './Lines'\nimport { Slices } from './Slices'\nimport { Points } from './Points'\nimport { Mesh } from './Mesh'\nimport {\n    LineSeries,\n    InferSeriesId,\n    InferY,\n    LineLayerId,\n    LineSvgProps,\n    Point,\n    PointColorContext,\n    SliceData,\n    LineCustomSvgLayerProps,\n    PointTooltipComponent,\n    SliceTooltipComponent,\n    LineSvgPropsWithDefaults,\n} from './types'\nimport { svgDefaultProps } from './defaults'\n\nfunction InnerLine<Series extends LineSeries>(\n    props: LineSvgProps<Series> & { forwardedRef: Ref<SVGSVGElement> }\n) {\n    const {\n        data,\n        xScale: xScaleSpec = svgDefaultProps.xScale,\n        xFormat,\n        yScale: yScaleSpec = svgDefaultProps.yScale,\n        yFormat,\n        curve = svgDefaultProps.curve as LineCurveFactoryId,\n        margin: partialMargin,\n        width,\n        height,\n        colors = svgDefaultProps.colors as OrdinalColorScaleConfig<Series>,\n        lineWidth = svgDefaultProps.lineWidth as number,\n        layers = svgDefaultProps.layers as readonly LineLayerId[],\n        enableArea = svgDefaultProps.enableArea,\n        areaBaselineValue = svgDefaultProps.areaBaselineValue as InferY<Series>,\n        areaOpacity = svgDefaultProps.areaOpacity,\n        areaBlendMode = svgDefaultProps.areaBlendMode,\n        enablePoints = svgDefaultProps.enablePoints,\n        pointSymbol,\n        pointSize = svgDefaultProps.pointSize,\n        pointColor = svgDefaultProps.pointColor as InheritedColorConfig<PointColorContext<Series>>,\n        pointBorderWidth = svgDefaultProps.pointBorderWidth,\n        pointBorderColor = svgDefaultProps.pointBorderColor as InheritedColorConfig<\n            Omit<Point<Series>, 'borderColor'>\n        >,\n        enablePointLabel = svgDefaultProps.enablePointLabel,\n        pointLabel = svgDefaultProps.pointLabel as string,\n        pointLabelYOffset,\n        enableGridX = svgDefaultProps.enableGridX,\n        gridXValues,\n        enableGridY = svgDefaultProps.enableGridY,\n        gridYValues,\n        axisTop,\n        axisRight,\n        axisBottom = svgDefaultProps.axisBottom,\n        axisLeft = svgDefaultProps.axisLeft,\n        defs = svgDefaultProps.defs,\n        fill = svgDefaultProps.fill,\n        markers,\n        legends = svgDefaultProps.legends,\n        isInteractive = svgDefaultProps.isInteractive,\n        useMesh = svgDefaultProps.useMesh,\n        debugMesh = svgDefaultProps.debugMesh,\n        onMouseEnter,\n        onMouseMove,\n        onMouseLeave,\n        onMouseDown,\n        onMouseUp,\n        onClick,\n        onDoubleClick,\n        onTouchStart,\n        onTouchMove,\n        onTouchEnd,\n        tooltip = svgDefaultProps.tooltip as PointTooltipComponent<Series>,\n        enableSlices = svgDefaultProps.enableSlices,\n        debugSlices = svgDefaultProps.debugSlices,\n        sliceTooltip = svgDefaultProps.sliceTooltip as SliceTooltipComponent<Series>,\n        enableCrosshair = svgDefaultProps.enableCrosshair,\n        crosshairType = svgDefaultProps.crosshairType as CrosshairType,\n        enableTouchCrosshair = svgDefaultProps.enableTouchCrosshair,\n        role = svgDefaultProps.role,\n        ariaLabel,\n        ariaLabelledBy,\n        ariaDescribedBy,\n        isFocusable = svgDefaultProps.isFocusable,\n        pointAriaLabel,\n        pointAriaLabelledBy,\n        pointAriaDescribedBy,\n        pointAriaHidden,\n        pointAriaDisabled,\n        initialHiddenIds = svgDefaultProps.initialHiddenIds as InferSeriesId<Series>[],\n        forwardedRef,\n    } = props\n\n    const { margin, innerWidth, innerHeight, outerWidth, outerHeight } = useDimensions(\n        width,\n        height,\n        partialMargin\n    )\n\n    const {\n        legendData,\n        toggleSeries,\n        lineGenerator,\n        areaGenerator,\n        series,\n        xScale,\n        yScale,\n        slices,\n        points,\n    } = useLine<Series>({\n        data,\n        xScale: xScaleSpec,\n        xFormat,\n        yScale: yScaleSpec,\n        yFormat,\n        width: innerWidth,\n        height: innerHeight,\n        colors,\n        curve,\n        areaBaselineValue,\n        pointColor,\n        pointBorderColor,\n        enableSlices,\n        initialHiddenIds,\n    })\n\n    const [currentPoint, setCurrentPoint] = useState<Point<Series> | null>(null)\n    const [currentSlice, setCurrentSlice] = useState<SliceData<Series> | null>(null)\n\n    const layerById: Record<LineLayerId, ReactNode> = {\n        grid: null,\n        markers: null,\n        axes: null,\n        areas: null,\n        crosshair: null,\n        lines: null,\n        points: null,\n        slices: null,\n        mesh: null,\n        legends: null,\n    }\n\n    if (layers.includes('grid') && (enableGridX || enableGridY)) {\n        layerById.grid = (\n            <Grid\n                key=\"grid\"\n                width={innerWidth}\n                height={innerHeight}\n                xScale={enableGridX ? (xScale as AnyScale) : null}\n                yScale={enableGridY ? (yScale as AnyScale) : null}\n                xValues={gridXValues}\n                yValues={gridYValues}\n            />\n        )\n    }\n\n    if (layers.includes('markers') && Array.isArray(markers) && markers.length > 0) {\n        layerById.markers = (\n            <CartesianMarkers\n                key=\"markers\"\n                markers={markers}\n                width={innerWidth}\n                height={innerHeight}\n                xScale={xScale}\n                yScale={yScale}\n            />\n        )\n    }\n\n    if (layers.includes('axes')) {\n        layerById.axes = (\n            <Axes\n                key=\"axes\"\n                xScale={xScale as AnyScale}\n                yScale={yScale as AnyScale}\n                width={innerWidth}\n                height={innerHeight}\n                top={axisTop}\n                right={axisRight}\n                bottom={axisBottom}\n                left={axisLeft}\n            />\n        )\n    }\n\n    if (layers.includes('lines')) {\n        layerById.lines = (\n            <Lines<Series>\n                key=\"lines\"\n                series={series}\n                lineGenerator={lineGenerator}\n                lineWidth={lineWidth}\n            />\n        )\n    }\n\n    if (layers.includes('legends') && legends.length > 0) {\n        layerById.legends = (\n            <Fragment key=\"legends\">\n                {legends.map((legend, i) => (\n                    <BoxLegendSvg\n                        key={i}\n                        {...legend}\n                        containerWidth={innerWidth}\n                        containerHeight={innerHeight}\n                        data={legend.data || legendData}\n                        toggleSerie={\n                            legend.toggleSerie\n                                ? (toggleSeries as (id: string | number) => void)\n                                : undefined\n                        }\n                    />\n                ))}\n            </Fragment>\n        )\n    }\n\n    const boundDefs = bindDefs(defs, series, fill)\n\n    if (enableArea) {\n        layerById.areas = (\n            <Areas<Series>\n                key=\"areas\"\n                areaGenerator={areaGenerator}\n                areaOpacity={areaOpacity}\n                areaBlendMode={areaBlendMode}\n                series={series}\n            />\n        )\n    }\n\n    if (isInteractive && enableSlices !== false) {\n        layerById.slices = (\n            <Slices<Series>\n                key=\"slices\"\n                slices={slices}\n                axis={enableSlices}\n                debug={debugSlices}\n                tooltip={sliceTooltip}\n                current={currentSlice}\n                setCurrent={setCurrentSlice}\n                onMouseEnter={onMouseEnter}\n                onMouseMove={onMouseMove}\n                onMouseLeave={onMouseLeave}\n                onMouseDown={onMouseDown}\n                onMouseUp={onMouseUp}\n                onClick={onClick}\n                onDoubleClick={onDoubleClick}\n                onTouchStart={onTouchStart}\n                onTouchMove={onTouchMove}\n                onTouchEnd={onTouchEnd}\n            />\n        )\n    }\n\n    if (enablePoints) {\n        layerById.points = (\n            <Points<Series>\n                key=\"points\"\n                points={points}\n                symbol={pointSymbol}\n                size={pointSize}\n                borderWidth={pointBorderWidth}\n                enableLabel={enablePointLabel}\n                label={pointLabel}\n                labelYOffset={pointLabelYOffset}\n                isFocusable={isFocusable}\n                setCurrentPoint={setCurrentPoint}\n                tooltip={tooltip}\n                margin={margin}\n                ariaLabel={pointAriaLabel}\n                ariaLabelledBy={pointAriaLabelledBy}\n                ariaDescribedBy={pointAriaDescribedBy}\n                ariaHidden={pointAriaHidden}\n                ariaDisabled={pointAriaDisabled}\n            />\n        )\n    }\n\n    if (isInteractive && enableCrosshair) {\n        if (currentPoint !== null) {\n            layerById.crosshair = (\n                <Crosshair\n                    key=\"crosshair\"\n                    width={innerWidth}\n                    height={innerHeight}\n                    x={currentPoint.x}\n                    y={currentPoint.y}\n                    type={crosshairType}\n                />\n            )\n        }\n        if (currentSlice !== null && enableSlices) {\n            layerById.crosshair = (\n                <Crosshair\n                    key=\"crosshair\"\n                    width={innerWidth}\n                    height={innerHeight}\n                    x={currentSlice.x}\n                    y={currentSlice.y}\n                    type={enableSlices}\n                />\n            )\n        }\n    }\n\n    if (isInteractive && useMesh && enableSlices === false) {\n        layerById.mesh = (\n            <Mesh<Series>\n                key=\"mesh\"\n                points={points}\n                width={innerWidth}\n                height={innerHeight}\n                margin={margin}\n                setCurrent={setCurrentPoint}\n                onMouseEnter={onMouseEnter}\n                onMouseMove={onMouseMove}\n                onMouseLeave={onMouseLeave}\n                onMouseDown={onMouseDown}\n                onMouseUp={onMouseUp}\n                onClick={onClick}\n                onDoubleClick={onDoubleClick}\n                onTouchStart={onTouchStart}\n                onTouchMove={onTouchMove}\n                onTouchEnd={onTouchEnd}\n                tooltip={tooltip}\n                enableTouchCrosshair={enableTouchCrosshair}\n                debug={debugMesh}\n            />\n        )\n    }\n\n    const customLayerProps: LineCustomSvgLayerProps<Series> = {\n        ...(props as LineSvgPropsWithDefaults<Series>),\n        innerWidth,\n        innerHeight,\n        series,\n        slices,\n        points,\n        xScale,\n        yScale,\n        lineGenerator,\n        areaGenerator,\n        currentPoint,\n        setCurrentPoint,\n        currentSlice,\n        setCurrentSlice,\n    }\n\n    return (\n        <SvgWrapper\n            defs={boundDefs}\n            width={outerWidth}\n            height={outerHeight}\n            margin={margin}\n            role={role}\n            ariaLabel={ariaLabel}\n            ariaLabelledBy={ariaLabelledBy}\n            ariaDescribedBy={ariaDescribedBy}\n            isFocusable={isFocusable}\n            ref={forwardedRef}\n        >\n            {layers.map((layer, i) => {\n                if (typeof layer === 'function') {\n                    return <Fragment key={i}>{layer(customLayerProps)}</Fragment>\n                }\n\n                return layerById[layer]\n            })}\n        </SvgWrapper>\n    )\n}\n\nexport const Line = forwardRef(\n    <Series extends LineSeries>(\n        {\n            isInteractive = svgDefaultProps.isInteractive,\n            animate = svgDefaultProps.animate,\n            motionConfig = svgDefaultProps.motionConfig,\n            theme,\n            renderWrapper,\n            ...otherProps\n        }: LineSvgProps<Series>,\n        ref: Ref<SVGSVGElement>\n    ) => (\n        <Container\n            animate={animate}\n            isInteractive={isInteractive}\n            motionConfig={motionConfig}\n            renderWrapper={renderWrapper}\n            theme={theme}\n        >\n            <InnerLine<Series> isInteractive={isInteractive} {...otherProps} forwardedRef={ref} />\n        </Container>\n    )\n) as <Series extends LineSeries>(\n    props: WithChartRef<LineSvgProps<Series>, SVGSVGElement>\n) => ReactElement\n", "import { forwardRef, Ref, ReactElement } from 'react'\nimport { ResponsiveWrapper, ResponsiveProps, WithChartRef } from '@nivo/core'\nimport { Line } from './Line'\nimport { LineSvgProps, LineSeries } from './types'\n\nexport const ResponsiveLine = forwardRef(\n    <Series extends LineSeries>(\n        {\n            defaultWidth,\n            defaultHeight,\n            onResize,\n            debounceResize,\n            ...props\n        }: ResponsiveProps<LineSvgProps<Series>>,\n        ref: Ref<SVGSVGElement>\n    ) => (\n        <ResponsiveWrapper\n            defaultWidth={defaultWidth}\n            defaultHeight={defaultHeight}\n            onResize={onResize}\n            debounceResize={debounceResize}\n        >\n            {({ width, height }: { width: number; height: number }) => (\n                <Line<Series> width={width} height={height} {...props} ref={ref} />\n            )}\n        </ResponsiveWrapper>\n    )\n) as <Series extends LineSeries>(\n    props: WithChartRef<ResponsiveProps<LineSvgProps<Series>>, SVGSVGElement>\n) => ReactElement\n", "import {\n    createElement,\n    useRef,\n    useEffect,\n    useState,\n    useCallback,\n    forwardRef,\n    ForwardedRef,\n    MouseEvent,\n    useMemo,\n    ReactElement,\n    Ref,\n} from 'react'\nimport { useDimensions, getRelativeCursor, isCursorInRect, Container, mergeRefs } from '@nivo/core'\nimport { useTheme } from '@nivo/theming'\nimport { renderAxesToCanvas, renderGridLinesToCanvas } from '@nivo/axes'\nimport { renderLegendToCanvas } from '@nivo/legends'\nimport { useTooltip } from '@nivo/tooltip'\nimport { useVoronoiMesh, renderVoronoiToCanvas, renderVoronoiCellToCanvas } from '@nivo/voronoi'\nimport { OrdinalColorScaleConfig, InheritedColorConfig } from '@nivo/colors'\nimport { useLine } from './hooks'\nimport {\n    InferY,\n    LineCanvasProps,\n    LineLayerId,\n    LineSeries,\n    PointTooltipComponent,\n    Point,\n    LineCustomCanvasLayerProps,\n    PointColorContext,\n} from './types'\nimport { canvasDefaultProps } from './defaults'\nimport { AnyScale } from '@nivo/scales'\n\nconst InnerLineCanvas = <Series extends LineSeries>({\n    width,\n    height,\n    margin: partialMargin,\n    pixelRatio = canvasDefaultProps.pixelRatio,\n    data,\n    xScale: xScaleSpec = canvasDefaultProps.xScale,\n    xFormat,\n    yScale: yScaleSpec = canvasDefaultProps.yScale,\n    yFormat,\n    curve = canvasDefaultProps.curve,\n    layers = canvasDefaultProps.layers as LineLayerId[],\n    colors = canvasDefaultProps.colors as OrdinalColorScaleConfig<Series>,\n    lineWidth = canvasDefaultProps.lineWidth,\n    enableArea = canvasDefaultProps.enableArea,\n    areaBaselineValue = canvasDefaultProps.areaBaselineValue as InferY<Series>,\n    areaOpacity = canvasDefaultProps.areaOpacity,\n    enablePoints = canvasDefaultProps.enablePoints,\n    pointSize = canvasDefaultProps.pointSize,\n    pointColor = canvasDefaultProps.pointColor as InheritedColorConfig<PointColorContext<Series>>,\n    pointBorderWidth = canvasDefaultProps.pointBorderWidth,\n    pointBorderColor = canvasDefaultProps.pointBorderColor as InheritedColorConfig<\n        Omit<Point<Series>, 'borderColor'>\n    >,\n    enableGridX = canvasDefaultProps.enableGridX,\n    gridXValues,\n    enableGridY = canvasDefaultProps.enableGridY,\n    gridYValues,\n    axisTop,\n    axisRight,\n    axisBottom = canvasDefaultProps.axisBottom,\n    axisLeft = canvasDefaultProps.axisLeft,\n    legends = canvasDefaultProps.legends,\n    isInteractive = canvasDefaultProps.isInteractive,\n    debugMesh = canvasDefaultProps.debugMesh,\n    onMouseLeave,\n    onMouseDown,\n    onMouseUp,\n    onClick,\n    onDoubleClick,\n    tooltip = canvasDefaultProps.tooltip as PointTooltipComponent<Series>,\n    role,\n    forwardedRef,\n}: Omit<LineCanvasProps<Series>, 'renderWrapper' | 'theme'> & {\n    forwardedRef: Ref<HTMLCanvasElement>\n}) => {\n    const canvasEl = useRef<HTMLCanvasElement | null>(null)\n\n    const { margin, innerWidth, innerHeight, outerWidth, outerHeight } = useDimensions(\n        width,\n        height,\n        partialMargin\n    )\n    const theme = useTheme()\n    const [currentPoint, setCurrentPoint] = useState<Point<Series> | null>(null)\n\n    const { lineGenerator, areaGenerator, series, xScale, yScale, points } = useLine<Series>({\n        data,\n        xScale: xScaleSpec,\n        xFormat,\n        yScale: yScaleSpec,\n        yFormat,\n        width: innerWidth,\n        height: innerHeight,\n        colors,\n        curve,\n        areaBaselineValue,\n        pointColor,\n        pointBorderColor,\n    })\n\n    const customLayerProps: LineCustomCanvasLayerProps<Series> = useMemo(\n        () => ({\n            innerWidth,\n            innerHeight,\n            series,\n            points,\n            xScale,\n            yScale,\n            lineWidth,\n            lineGenerator,\n            areaGenerator,\n            currentPoint,\n            setCurrentPoint,\n        }),\n        [\n            innerWidth,\n            innerHeight,\n            series,\n            points,\n            xScale,\n            yScale,\n            lineWidth,\n            lineGenerator,\n            areaGenerator,\n            currentPoint,\n            setCurrentPoint,\n        ]\n    )\n\n    const { delaunay, voronoi } = useVoronoiMesh({\n        points,\n        width: innerWidth,\n        height: innerHeight,\n        debug: debugMesh,\n    })\n\n    useEffect(() => {\n        if (canvasEl.current === null) return\n\n        canvasEl.current.width = outerWidth * pixelRatio\n        canvasEl.current.height = outerHeight * pixelRatio\n\n        const ctx = canvasEl.current.getContext('2d')!\n\n        ctx.scale(pixelRatio, pixelRatio)\n\n        ctx.fillStyle = theme.background\n        ctx.fillRect(0, 0, outerWidth, outerHeight)\n        ctx.translate(margin.left, margin.top)\n\n        layers.forEach(layer => {\n            if (typeof layer === 'function') {\n                layer(ctx, customLayerProps)\n            }\n\n            const gridLineWidth = theme.grid.line.strokeWidth ?? 0\n            if (layer === 'grid' && typeof gridLineWidth !== 'string' && gridLineWidth > 0) {\n                ctx.lineWidth = gridLineWidth\n                ctx.strokeStyle = theme.grid.line.stroke as string\n\n                if (enableGridX) {\n                    renderGridLinesToCanvas(ctx, {\n                        width: innerWidth,\n                        height: innerHeight,\n                        scale: xScale as AnyScale,\n                        axis: 'x',\n                        values: gridXValues,\n                    })\n                }\n\n                if (enableGridY) {\n                    renderGridLinesToCanvas(ctx, {\n                        width: innerWidth,\n                        height: innerHeight,\n                        scale: yScale as AnyScale,\n                        axis: 'y',\n                        values: gridYValues,\n                    })\n                }\n            }\n\n            if (layer === 'axes') {\n                renderAxesToCanvas(ctx, {\n                    xScale: xScale as AnyScale,\n                    yScale: yScale as AnyScale,\n                    width: innerWidth,\n                    height: innerHeight,\n                    top: axisTop,\n                    right: axisRight,\n                    bottom: axisBottom,\n                    left: axisLeft,\n                    theme,\n                })\n            }\n\n            if (layer === 'areas' && enableArea === true) {\n                ctx.save()\n                ctx.globalAlpha = areaOpacity\n\n                areaGenerator.context(ctx)\n                for (let i = series.length - 1; i >= 0; i--) {\n                    ctx.fillStyle = series[i].color\n                    ctx.beginPath()\n                    areaGenerator(series[i].data.map(d => d.position))\n                    ctx.fill()\n                }\n\n                ctx.restore()\n            }\n\n            if (layer === 'lines') {\n                lineGenerator.context(ctx)\n                series.forEach(seriesItem => {\n                    ctx.strokeStyle = seriesItem.color\n                    ctx.lineWidth = lineWidth\n                    ctx.beginPath()\n                    lineGenerator(seriesItem.data.map(d => d.position))\n                    ctx.stroke()\n                })\n            }\n\n            if (layer === 'points' && enablePoints === true && pointSize > 0) {\n                points.forEach(point => {\n                    ctx.fillStyle = point.color\n                    ctx.beginPath()\n                    ctx.arc(point.x, point.y, pointSize / 2, 0, 2 * Math.PI)\n                    ctx.fill()\n\n                    if (pointBorderWidth > 0) {\n                        ctx.strokeStyle = point.borderColor\n                        ctx.lineWidth = pointBorderWidth\n                        ctx.stroke()\n                    }\n                })\n            }\n\n            if (layer === 'mesh' && debugMesh === true && voronoi !== undefined) {\n                renderVoronoiToCanvas(ctx, voronoi)\n                if (currentPoint) {\n                    renderVoronoiCellToCanvas(ctx, voronoi, currentPoint.absIndex)\n                }\n            }\n\n            if (layer === 'legends') {\n                const legendData = series\n                    .map(serie => ({\n                        id: serie.id,\n                        label: serie.id,\n                        color: serie.color,\n                    }))\n                    .reverse()\n\n                legends.forEach(legend => {\n                    renderLegendToCanvas(ctx, {\n                        ...legend,\n                        data: legend.data || legendData,\n                        containerWidth: innerWidth,\n                        containerHeight: innerHeight,\n                        theme,\n                    })\n                })\n            }\n        })\n    }, [\n        canvasEl,\n        innerWidth,\n        outerWidth,\n        innerHeight,\n        outerHeight,\n        margin.left,\n        margin.top,\n        pixelRatio,\n        layers,\n        theme,\n        lineGenerator,\n        series,\n        xScale,\n        yScale,\n        enableGridX,\n        gridXValues,\n        enableGridY,\n        gridYValues,\n        axisTop,\n        axisRight,\n        axisBottom,\n        axisLeft,\n        legends,\n        points,\n        enablePoints,\n        pointSize,\n        pointBorderWidth,\n        currentPoint,\n        customLayerProps,\n        debugMesh,\n        enableArea,\n        areaGenerator,\n        areaOpacity,\n        lineWidth,\n        voronoi,\n    ])\n\n    const getPointFromMouseEvent = useCallback(\n        (event: MouseEvent<HTMLCanvasElement>) => {\n            if (!canvasEl.current) return null\n\n            const [x, y] = getRelativeCursor(canvasEl.current, event)\n            if (!isCursorInRect(margin.left, margin.top, innerWidth, innerHeight, x, y)) return null\n\n            const pointIndex = delaunay.find(x - margin.left, y - margin.top)\n            return points[pointIndex]\n        },\n        [canvasEl, margin, innerWidth, innerHeight, delaunay, points]\n    )\n\n    const { showTooltipFromEvent, hideTooltip } = useTooltip()\n\n    const handleMouseHover = useCallback(\n        (event: MouseEvent<HTMLCanvasElement>) => {\n            const point = getPointFromMouseEvent(event)\n            setCurrentPoint(point)\n\n            if (point) {\n                showTooltipFromEvent(createElement(tooltip, { point }), event)\n            } else {\n                hideTooltip()\n            }\n        },\n        [getPointFromMouseEvent, setCurrentPoint, showTooltipFromEvent, hideTooltip, tooltip]\n    )\n\n    const handleMouseLeave = useCallback(\n        (event: MouseEvent<HTMLCanvasElement>) => {\n            hideTooltip()\n            setCurrentPoint(null)\n            if (currentPoint) onMouseLeave?.(currentPoint, event)\n        },\n        [hideTooltip, setCurrentPoint, onMouseLeave, currentPoint]\n    )\n\n    const handleMouseDown = useCallback(\n        (event: MouseEvent<HTMLCanvasElement>) => {\n            if (onMouseDown) {\n                const point = getPointFromMouseEvent(event)\n                if (point) onMouseDown(point, event)\n            }\n        },\n        [getPointFromMouseEvent, onMouseDown]\n    )\n\n    const handleMouseUp = useCallback(\n        (event: MouseEvent<HTMLCanvasElement>) => {\n            if (onMouseUp) {\n                const point = getPointFromMouseEvent(event)\n                if (point) onMouseUp(point, event)\n            }\n        },\n        [getPointFromMouseEvent, onMouseUp]\n    )\n\n    const handleClick = useCallback(\n        (event: MouseEvent<HTMLCanvasElement>) => {\n            if (onClick) {\n                const point = getPointFromMouseEvent(event)\n                if (point) onClick(point, event)\n            }\n        },\n        [getPointFromMouseEvent, onClick]\n    )\n\n    const handleDoubleClick = useCallback(\n        (event: MouseEvent<HTMLCanvasElement>) => {\n            if (onDoubleClick) {\n                const point = getPointFromMouseEvent(event)\n                if (point) onDoubleClick(point, event)\n            }\n        },\n        [getPointFromMouseEvent, onDoubleClick]\n    )\n\n    return (\n        <canvas\n            ref={mergeRefs<HTMLCanvasElement>(canvasEl, forwardedRef)}\n            width={outerWidth * pixelRatio}\n            height={outerHeight * pixelRatio}\n            style={{\n                width: outerWidth,\n                height: outerHeight,\n                cursor: isInteractive ? 'auto' : 'normal',\n            }}\n            onMouseEnter={isInteractive ? handleMouseHover : undefined}\n            onMouseMove={isInteractive ? handleMouseHover : undefined}\n            onMouseLeave={isInteractive ? handleMouseLeave : undefined}\n            onMouseDown={isInteractive ? handleMouseDown : undefined}\n            onMouseUp={isInteractive ? handleMouseUp : undefined}\n            onClick={isInteractive ? handleClick : undefined}\n            onDoubleClick={isInteractive ? handleDoubleClick : undefined}\n            role={role}\n        />\n    )\n}\n\nexport const LineCanvas = forwardRef(\n    <Series extends LineSeries>(\n        { isInteractive, renderWrapper, theme, ...props }: LineCanvasProps<Series>,\n        ref: Ref<HTMLCanvasElement>\n    ) => (\n        <Container {...{ isInteractive, renderWrapper, theme }} animate={false}>\n            <InnerLineCanvas<Series> {...props} forwardedRef={ref} />\n        </Container>\n    )\n) as <Series extends LineSeries>(\n    props: LineCanvasProps<Series> & {\n        ref?: ForwardedRef<HTMLCanvasElement>\n    }\n) => ReactElement\n", "import { forwardRef, Ref, ReactElement } from 'react'\nimport { ResponsiveWrapper, ResponsiveProps, WithChartRef } from '@nivo/core'\nimport { LineCanvasProps, LineSeries } from './types'\nimport { LineCanvas } from './LineCanvas'\n\nexport const ResponsiveLineCanvas = forwardRef(\n    <Series extends LineSeries>(\n        {\n            defaultWidth,\n            defaultHeight,\n            onResize,\n            debounceResize,\n            ...props\n        }: ResponsiveProps<LineCanvasProps<Series>>,\n        ref: Ref<HTMLCanvasElement>\n    ) => (\n        <ResponsiveWrapper\n            defaultWidth={defaultWidth}\n            defaultHeight={defaultWidth}\n            onResize={onResize}\n            debounceResize={debounceResize}\n        >\n            {({ width, height }: { width: number; height: number }) => (\n                <LineCanvas<Series> width={width} height={height} {...props} ref={ref} />\n            )}\n        </ResponsiveWrapper>\n    )\n) as <Series extends LineSeries>(\n    props: WithChartRef<ResponsiveProps<LineCanvasProps<Series>>, HTMLCanvasElement>\n) => ReactElement\n", "import { FunctionComponent, MouseEvent, TouchEvent, AriaAttributes } from 'react'\nimport { Line, Area } from 'd3-shape'\nimport {\n    Dimensions,\n    Box,\n    MotionProps,\n    CssMixBlendMode,\n    ValueFormat,\n    SvgDefsAndFill,\n    CartesianMarkerProps,\n    PropertyAccessor,\n    LineCurveFactoryId,\n    DotsItemSymbolComponent,\n} from '@nivo/core'\nimport { PartialTheme } from '@nivo/theming'\nimport { AxisProps, CanvasAxisProps } from '@nivo/axes'\nimport { InheritedColorConfig, OrdinalColorScaleConfig } from '@nivo/colors'\nimport { ScaleSpec, TicksSpec } from '@nivo/scales'\nimport { LegendProps } from '@nivo/legends'\nimport { CrosshairType } from '@nivo/tooltip'\n\nexport type AllowedSeriesId = string | number\n// `null` is allowed in the data to indicate a missing value.\nexport type AllowedValue = string | number | Date | null\nexport type LineSeries = {\n    id: AllowedSeriesId\n    data: readonly { x: AllowedValue; y: AllowedValue }[]\n}\n\nexport type InferSeriesId<T> = T extends { id: infer Id } ? Id : never\n\nexport type InferX<T> = T extends { data: ReadonlyArray<infer D> }\n    ? D extends { x: infer X }\n        ? X\n        : never\n    : never\nexport type InferY<T> = T extends { data: ReadonlyArray<infer D> }\n    ? D extends { y: infer Y }\n        ? Y\n        : never\n    : never\n\nexport type DefaultSeries = {\n    id: string\n    data: readonly {\n        x: string | null\n        y: number | null\n    }[]\n}\n\nexport interface ComputedDatum<Series extends LineSeries> {\n    data: Series['data'][number]\n    position: {\n        x: number\n        y: number\n    }\n}\n\nexport type ComputedSeries<Series extends LineSeries> = Omit<Series, 'data' | 'id'> & {\n    id: InferSeriesId<Series>\n    data: readonly ComputedDatum<Series>[]\n    color: string\n}\n\nexport interface Point<Series extends LineSeries> {\n    id: string\n    indexInSeries: number\n    absIndex: number\n    seriesIndex: number\n    seriesId: InferSeriesId<Series>\n    seriesColor: string\n    x: number\n    y: number\n    color: string\n    borderColor: string\n    data: Series['data'][number] & {\n        xFormatted: string\n        yFormatted: string\n    }\n}\n\nexport type PointColorContext<Series extends LineSeries> = {\n    series: ComputedSeries<Series>\n    point: Omit<Point<Series>, 'color' | 'borderColor'>\n}\n\nexport interface SliceData<Series extends LineSeries> {\n    id: string\n    x0: number\n    x: number\n    y0: number\n    y: number\n    width: number\n    height: number\n    points: readonly Point<Series>[]\n}\n\nexport type PointOrSliceData<Series extends LineSeries> = Point<Series> | SliceData<Series>\nexport function isPoint<Series extends LineSeries>(\n    data: PointOrSliceData<Series>\n): data is Point<Series> {\n    return (data as Point<Series>).seriesId !== undefined\n}\nexport function isSliceData<Series extends LineSeries>(\n    data: PointOrSliceData<Series>\n): data is SliceData<Series> {\n    return (data as SliceData<Series>).points !== undefined\n}\n\nexport interface DataProps<Series extends LineSeries> {\n    data: readonly Series[]\n}\n\nexport type LineGenerator = Line<{ x: number; y: number }>\nexport type AreaGenerator = Area<{ x: number; y: number }>\n\nexport interface PointTooltipProps<Series extends LineSeries> {\n    point: Point<Series>\n}\nexport type PointTooltipComponent<Series extends LineSeries> = FunctionComponent<\n    PointTooltipProps<Series>\n>\n\nexport interface SliceTooltipProps<Series extends LineSeries> {\n    axis: 'x' | 'y'\n    slice: SliceData<Series>\n}\nexport type SliceTooltipComponent<Series extends LineSeries> = FunctionComponent<\n    SliceTooltipProps<Series>\n>\n\nexport type PointOrSliceMouseHandler<Series extends LineSeries> = (\n    datum: Readonly<Point<Series>> | Readonly<SliceData<Series>>,\n    event: MouseEvent\n) => void\nexport type PointOrSliceTouchHandler<Series extends LineSeries> = (\n    datum: Readonly<Point<Series>> | Readonly<SliceData<Series>>,\n    event: TouchEvent\n) => void\n\nexport type LineLayerId =\n    | 'grid'\n    | 'markers'\n    | 'axes'\n    | 'areas'\n    | 'crosshair'\n    | 'lines'\n    | 'slices'\n    | 'points'\n    | 'mesh'\n    | 'legends'\n\nexport interface CommonCustomLayerProps<Series extends LineSeries> {\n    innerWidth: number\n    innerHeight: number\n    series: readonly ComputedSeries<Series>[]\n    points: readonly Point<Series>[]\n    xScale: (x: InferX<Series>) => number\n    yScale: (y: InferY<Series>) => number\n    lineGenerator: LineGenerator\n    areaGenerator: AreaGenerator\n    currentPoint: Point<Series> | null\n    setCurrentPoint: (point: Point<Series> | null) => void\n}\n\nexport type LineCustomSvgLayerProps<Series extends LineSeries> = Omit<\n    LineSvgPropsWithDefaults<Series>,\n    'xScale' | 'yScale'\n> &\n    CommonCustomLayerProps<Series> & {\n        slices: readonly SliceData<Series>[]\n        currentSlice: SliceData<Series> | null\n        setCurrentSlice: (slice: SliceData<Series> | null) => void\n    }\nexport type LineCustomSvgLayer<Series extends LineSeries> = FunctionComponent<\n    LineCustomSvgLayerProps<Series>\n>\nexport type LineSvgLayer<Series extends LineSeries> = LineLayerId | LineCustomSvgLayer<Series>\n\nexport type LineCustomCanvasLayerProps<Series extends LineSeries> = CommonCustomLayerProps<Series>\nexport type LineCustomCanvasLayer<Series extends LineSeries> = (\n    context: CanvasRenderingContext2D,\n    props: LineCustomCanvasLayerProps<Series>\n) => void\nexport type LineCanvasLayer<Series extends LineSeries> = LineLayerId | LineCustomCanvasLayer<Series>\n\nexport type CommonLineProps<Series extends LineSeries> = {\n    xScale: ScaleSpec\n    xFormat?: ValueFormat<InferX<Series>>\n    yScale: ScaleSpec\n    yFormat?: ValueFormat<InferY<Series>>\n    margin: Box\n    curve: LineCurveFactoryId\n    theme: PartialTheme\n    colors: OrdinalColorScaleConfig<Series>\n    lineWidth: number\n    enablePoints: boolean\n    pointSymbol?: DotsItemSymbolComponent<Point<Series>>\n    pointSize: number\n    pointColor: InheritedColorConfig<PointColorContext<Series>>\n    pointBorderWidth: number\n    pointBorderColor: InheritedColorConfig<Omit<Point<Series>, 'borderColor'>>\n    enableArea: boolean\n    areaBaselineValue: InferY<Series>\n    areaOpacity: number\n    enableGridX: boolean\n    gridXValues?: TicksSpec<InferX<Series>>\n    enableGridY: boolean\n    gridYValues?: TicksSpec<InferY<Series>>\n    legends: readonly LegendProps[]\n    isInteractive: boolean\n    debugMesh: boolean\n    onMouseEnter?: PointOrSliceMouseHandler<Series>\n    onMouseMove?: PointOrSliceMouseHandler<Series>\n    onMouseLeave?: PointOrSliceMouseHandler<Series>\n    onMouseDown?: PointOrSliceMouseHandler<Series>\n    onMouseUp?: PointOrSliceMouseHandler<Series>\n    onClick?: PointOrSliceMouseHandler<Series>\n    onDoubleClick?: PointOrSliceMouseHandler<Series>\n    onTouchStart?: PointOrSliceTouchHandler<Series>\n    onTouchMove?: PointOrSliceTouchHandler<Series>\n    onTouchEnd?: PointOrSliceTouchHandler<Series>\n    tooltip: PointTooltipComponent<Series>\n    sliceTooltip: SliceTooltipComponent<Series>\n    renderWrapper: boolean\n    role?: string\n}\n\nexport interface LineSvgExtraProps<Series extends LineSeries> {\n    layers: readonly LineSvgLayer<Series>[]\n    enablePointLabel: boolean\n    pointLabel: PropertyAccessor<Point<Series>, string>\n    pointLabelYOffset?: number\n    areaBlendMode: CssMixBlendMode\n    axisTop?: AxisProps | null\n    axisRight?: AxisProps | null\n    axisBottom?: AxisProps | null\n    axisLeft?: AxisProps | null\n    useMesh: boolean\n    enableSlices: 'x' | 'y' | false\n    debugSlices: boolean\n    enableCrosshair: boolean\n    crosshairType: CrosshairType\n    enableTouchCrosshair: boolean\n    markers?: readonly CartesianMarkerProps[]\n    initialHiddenIds: readonly InferSeriesId<Series>[]\n    animate: boolean\n    motionConfig: MotionProps['motionConfig']\n    ariaLabel?: AriaAttributes['aria-label']\n    ariaLabelledBy?: AriaAttributes['aria-labelledby']\n    ariaDescribedBy?: AriaAttributes['aria-describedby']\n    isFocusable: boolean\n    pointAriaLabel?: (point: Point<Series>) => AriaAttributes['aria-label']\n    pointAriaLabelledBy?: (point: Point<Series>) => AriaAttributes['aria-labelledby']\n    pointAriaDescribedBy?: (point: Point<Series>) => AriaAttributes['aria-describedby']\n    pointAriaHidden?: (point: Point<Series>) => AriaAttributes['aria-hidden']\n    pointAriaDisabled?: (point: Point<Series>) => AriaAttributes['aria-disabled']\n}\nexport type LineSvgProps<Series extends LineSeries> = DataProps<Series> &\n    Dimensions &\n    Partial<CommonLineProps<Series>> &\n    Partial<LineSvgExtraProps<Series>> &\n    SvgDefsAndFill<any>\nexport type LineSvgPropsWithDefaults<Series extends LineSeries> = DataProps<Series> &\n    Dimensions &\n    CommonLineProps<Series> &\n    LineSvgExtraProps<Series> &\n    SvgDefsAndFill<any>\n\nexport interface LineCanvasExtraProps<Series extends LineSeries> {\n    layers: readonly LineCanvasLayer<Series>[]\n    pixelRatio: number\n    axisTop?: CanvasAxisProps | null\n    axisRight?: CanvasAxisProps | null\n    axisBottom?: CanvasAxisProps | null\n    axisLeft?: CanvasAxisProps | null\n}\nexport type LineCanvasProps<Series extends LineSeries> = DataProps<Series> &\n    Dimensions &\n    Partial<CommonLineProps<Series>> &\n    Partial<LineCanvasExtraProps<Series>>\nexport type LineCanvasPropsWithDefaults<Series extends LineSeries> = DataProps<Series> &\n    Dimensions &\n    CommonLineProps<Series> &\n    LineCanvasExtraProps<Series>\n"],
  "mappings": "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B,QAAI,MAAM,QAAQ,UAAU;AAC1B,WAAK,SAAS;AAAA,IAChB;AACA,uBAAmB,MAAM,KAAK;AAAA,EAChC;AACF;AAGA,IAAI,aAAa;AAAA,EACf;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAC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",
  "names": ["n", "i", "z", "z2", "t", "commonDefaultProps", "xScale", "type", "yScale", "min", "max", "curve", "colors", "scheme", "lineWidth", "layers", "enablePoints", "pointSize", "pointColor", "from", "pointBorderWidth", "pointBorderColor", "theme", "enableArea", "areaBaselineValue", "areaOpacity", "enableGridX", "enableGridY", "legends", "isInteractive", "tooltip", "memo", "_ref", "point", "_jsx", "BasicTooltip", "id", "_jsxs", "children", "data", "xFormatted", "yFormatted", "enableChip", "color", "seriesColor", "sliceTooltip", "slice", "axis", "useTheme", "otherAxis", "TableTooltip", "rows", "points", "map", "Chip", "style", "chip", "seriesId", "tableCellValue", "debugMesh", "renderWrapper", "svgDefaultProps", "_extends", "defs", "fill", "enablePointLabel", "pointLabel", "areaBlendMode", "axisTop", "axisRight", "axisBottom", "defaultAxisProps", "axisLeft", "useMesh", "enableSlices", "debugSlices", "enableCrosshair", "crosshairType", "enableTouchCrosshair", "initialHiddenIds", "animate", "motionConfig", "role", "isFocusable", "canvasDefaultProps", "pixelRatio", "window", "_window$devicePixelRa", "devicePixelRatio", "useLineGenerator", "useMemo", "line", "defined", "d", "x", "y", "curveFromProp", "useAreaGenerator", "area", "y1", "y0", "useSlices", "_ref3", "componentId", "width", "height", "Map", "forEach", "has", "get", "push", "set", "Array", "entries", "sort", "a", "b", "_ref4", "i", "slices", "x0", "sliceWidth", "slicePoints", "prevSlice", "nextSlice", "reverse", "_ref5", "sliceHeight", "LINE_UNIQUE_ID_PREFIX", "useLine", "_ref6", "_ref6$xScale", "xScaleSpec", "xFormat", "_ref6$yScale", "yScaleSpec", "yFormat", "_ref6$colors", "_ref6$curve", "_ref6$areaBaselineVal", "_ref6$pointColor", "_ref6$pointBorderColo", "_ref6$enableSlices", "_ref6$initialHiddenId", "useState", "uniqueId", "formatX", "useValueFormatter", "formatY", "getColor", "useOrdinalColorScale", "getPointColor", "useInheritedColor", "getPointBorderColor", "_useState2", "hiddenIds", "setHiddenIds", "_useMemo", "computeXYScalesForSeries", "filter", "item", "indexOf", "rawSeries", "series", "_useMemo2", "dataWithColor", "seriesItem", "label", "datum", "find", "Boolean", "legendData", "hidden", "toggleSeries", "useCallback", "state", "concat", "_ref2", "reduce", "acc", "seriesIndex", "position", "indexInSeries", "absIndex", "length", "borderColor", "lineGenerator", "areaGenerator", "AreaPath", "path", "_useMotionConfig", "useMotionConfig", "springConfig", "config", "animatedPath", "useAnimatedPath", "animatedProps", "useSpring", "immediate", "animated", "fillOpacity", "strokeWidth", "mixBlendMode", "Areas", "reversedSeries", "LinesItem", "thickness", "stroke", "Lines", "_Fragment", "SlicesItem", "debug", "isCurrent", "setCurrent", "onMouseEnter", "onMouseMove", "onMouseLeave", "onMouseDown", "onMouseUp", "onClick", "onDoubleClick", "onTouchStart", "onTouchMove", "onTouchEnd", "_useTooltip", "useTooltip", "showTooltipFromEvent", "hideTooltip", "handleMouseEnter", "event", "createElement", "handleMouseMove", "handleMouseLeave", "handleMouseDown", "handleMouseUp", "handleClick", "handleDoubleClick", "handeOnTouchStart", "handeOnTouchMove", "touchPoint", "touches", "touchingElement", "document", "elementFromPoint", "clientX", "clientY", "touchingSliceId", "getAttribute", "handleOnTouchEnd", "strokeOpacity", "Slices", "current", "Points", "symbol", "size", "borderWidth", "enableLabel", "labelYOffset", "setCurrentPoint", "margin", "ariaLabel", "ariaLabelledBy", "ariaDescribedBy", "ariaHidden", "ariaDisabled", "getLabel", "getLabelGenerator", "showTooltipAt", "mappedPoints", "onFocus", "left", "top", "onBlur", "undefined", "DotsItem", "testId", "Mesh", "handleTouchStart", "handleTouchMove", "handleTouchEnd", "BaseMesh", "nodes", "InnerLine", "props", "_props$xScale", "_props$yScale", "_props$curve", "partialMargin", "_props$colors", "_props$lineWidth", "_props$layers", "_props$enableArea", "_props$areaBaselineVa", "_props$areaOpacity", "_props$areaBlendMode", "_props$enablePoints", "pointSymbol", "_props$pointSize", "_props$pointColor", "_props$pointBorderWid", "_props$pointBorderCol", "_props$enablePointLab", "_props$pointLabel", "pointLabelYOffset", "_props$enableGridX", "gridXValues", "_props$enableGridY", "gridYValues", "_props$axisBottom", "_props$axisLeft", "_props$defs", "_props$fill", "markers", "_props$legends", "_props$isInteractive", "_props$useMesh", "_props$debugMesh", "_props$tooltip", "_props$enableSlices", "_props$debugSlices", "_props$sliceTooltip", "_props$enableCrosshai", "_props$crosshairType", "_props$enableTouchCro", "_props$role", "_props$isFocusable", "pointAriaLabel", "pointAriaLabelledBy", "pointAriaDescribedBy", "pointAriaHidden", "pointAriaDisabled", "_props$initialHiddenI", "forwardedRef", "_useDimensions", "useDimensions", "innerWidth", "innerHeight", "outerWidth", "outerHeight", "_useLine", "_useState", "currentPoint", "currentSlice", "setCurrentSlice", "layerById", "grid", "axes", "areas", "crosshair", "lines", "mesh", "includes", "Grid", "xValues", "yValues", "isArray", "CartesianMarkers", "Axes", "right", "bottom", "Fragment", "legend", "BoxLegendSvg", "containerWidth", "containerHeight", "toggleSerie", "boundDefs", "bindDefs", "Crosshair", "customLayerProps", "SvgWrapper", "ref", "layer", "Line", "forwardRef", "_ref$isInteractive", "_ref$animate", "_ref$motionConfig", "otherProps", "_objectWithoutPropertiesLoose", "_excluded", "Container", "ResponsiveLine", "defaultWidth", "defaultHeight", "onResize", "debounceResize", "ResponsiveWrapper", "InnerLineCanvas", "_ref$pixelRatio", "_ref$xScale", "_ref$yScale", "_ref$curve", "_ref$layers", "_ref$colors", "_ref$lineWidth", "_ref$enableArea", "_ref$areaBaselineValu", "_ref$areaOpacity", "_ref$enablePoints", "_ref$pointSize", "_ref$pointColor", "_ref$pointBorderWidth", "_ref$pointBorderColor", "_ref$enableGridX", "_ref$enableGridY", "_ref$axisBottom", "_ref$axisLeft", "_ref$legends", "_ref$debugMesh", "_ref$tooltip", "canvasEl", "useRef", "_useVoronoiMesh", "useVoronoiMesh", "delaunay", "voronoi", "useEffect", "ctx", "getContext", "scale", "fillStyle", "background", "fillRect", "translate", "_theme$grid$line$stro", "gridLineWidth", "strokeStyle", "renderGridLinesToCanvas", "values", "renderAxesToCanvas", "save", "globalAlpha", "context", "beginPath", "restore", "arc", "Math", "PI", "renderVoronoiToCanvas", "renderVoronoiCellToCanvas", "serie", "renderLegendToCanvas", "getPointFromMouseEvent", "_getRelativeCursor", "getRelativeCursor", "isCursorInRect", "pointIndex", "handleMouseHover", "mergeRefs", "cursor", "LineCanvas", "ResponsiveLineCanvas", "isPoint", "isSliceData"]
}
