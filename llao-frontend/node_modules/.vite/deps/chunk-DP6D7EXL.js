import {
  $r,
  Fr,
  Rt,
  cn,
  kn,
  linear,
  un,
  yn,
  z
} from "./chunk-FQLOU77L.js";
import {
  require_jsx_runtime
} from "./chunk-OT5EQO2H.js";
import {
  require_react
} from "./chunk-OU5AQDZK.js";
import {
  __toESM
} from "./chunk-EWTE5DHJ.js";

// node_modules/@nivo/voronoi/dist/nivo-voronoi.mjs
var import_react = __toESM(require_react(), 1);

// node_modules/robust-predicates/esm/util.js
var epsilon = 11102230246251565e-32;
var splitter = 134217729;
var resulterrbound = (3 + 8 * epsilon) * epsilon;
function sum(elen, e2, flen, f, h) {
  let Q, Qnew, hh, bvirt;
  let enow = e2[0];
  let fnow = f[0];
  let eindex = 0;
  let findex = 0;
  if (fnow > enow === fnow > -enow) {
    Q = enow;
    enow = e2[++eindex];
  } else {
    Q = fnow;
    fnow = f[++findex];
  }
  let hindex = 0;
  if (eindex < elen && findex < flen) {
    if (fnow > enow === fnow > -enow) {
      Qnew = enow + Q;
      hh = Q - (Qnew - enow);
      enow = e2[++eindex];
    } else {
      Qnew = fnow + Q;
      hh = Q - (Qnew - fnow);
      fnow = f[++findex];
    }
    Q = Qnew;
    if (hh !== 0) {
      h[hindex++] = hh;
    }
    while (eindex < elen && findex < flen) {
      if (fnow > enow === fnow > -enow) {
        Qnew = Q + enow;
        bvirt = Qnew - Q;
        hh = Q - (Qnew - bvirt) + (enow - bvirt);
        enow = e2[++eindex];
      } else {
        Qnew = Q + fnow;
        bvirt = Qnew - Q;
        hh = Q - (Qnew - bvirt) + (fnow - bvirt);
        fnow = f[++findex];
      }
      Q = Qnew;
      if (hh !== 0) {
        h[hindex++] = hh;
      }
    }
  }
  while (eindex < elen) {
    Qnew = Q + enow;
    bvirt = Qnew - Q;
    hh = Q - (Qnew - bvirt) + (enow - bvirt);
    enow = e2[++eindex];
    Q = Qnew;
    if (hh !== 0) {
      h[hindex++] = hh;
    }
  }
  while (findex < flen) {
    Qnew = Q + fnow;
    bvirt = Qnew - Q;
    hh = Q - (Qnew - bvirt) + (fnow - bvirt);
    fnow = f[++findex];
    Q = Qnew;
    if (hh !== 0) {
      h[hindex++] = hh;
    }
  }
  if (Q !== 0 || hindex === 0) {
    h[hindex++] = Q;
  }
  return hindex;
}
function estimate(elen, e2) {
  let Q = e2[0];
  for (let i2 = 1; i2 < elen; i2++) Q += e2[i2];
  return Q;
}
function vec(n2) {
  return new Float64Array(n2);
}

// node_modules/robust-predicates/esm/orient2d.js
var ccwerrboundA = (3 + 16 * epsilon) * epsilon;
var ccwerrboundB = (2 + 12 * epsilon) * epsilon;
var ccwerrboundC = (9 + 64 * epsilon) * epsilon * epsilon;
var B = vec(4);
var C1 = vec(8);
var C2 = vec(12);
var D = vec(16);
var u = vec(4);
function orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {
  let acxtail, acytail, bcxtail, bcytail;
  let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u32;
  const acx = ax - cx;
  const bcx = bx - cx;
  const acy = ay - cy;
  const bcy = by - cy;
  s1 = acx * bcy;
  c = splitter * acx;
  ahi = c - (c - acx);
  alo = acx - ahi;
  c = splitter * bcy;
  bhi = c - (c - bcy);
  blo = bcy - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = acy * bcx;
  c = splitter * acy;
  ahi = c - (c - acy);
  alo = acy - ahi;
  c = splitter * bcx;
  bhi = c - (c - bcx);
  blo = bcx - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  B[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  B[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u32 = _j + _i;
  bvirt = u32 - _j;
  B[2] = _j - (u32 - bvirt) + (_i - bvirt);
  B[3] = u32;
  let det = estimate(4, B);
  let errbound = ccwerrboundB * detsum;
  if (det >= errbound || -det >= errbound) {
    return det;
  }
  bvirt = ax - acx;
  acxtail = ax - (acx + bvirt) + (bvirt - cx);
  bvirt = bx - bcx;
  bcxtail = bx - (bcx + bvirt) + (bvirt - cx);
  bvirt = ay - acy;
  acytail = ay - (acy + bvirt) + (bvirt - cy);
  bvirt = by - bcy;
  bcytail = by - (bcy + bvirt) + (bvirt - cy);
  if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {
    return det;
  }
  errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);
  det += acx * bcytail + bcy * acxtail - (acy * bcxtail + bcx * acytail);
  if (det >= errbound || -det >= errbound) return det;
  s1 = acxtail * bcy;
  c = splitter * acxtail;
  ahi = c - (c - acxtail);
  alo = acxtail - ahi;
  c = splitter * bcy;
  bhi = c - (c - bcy);
  blo = bcy - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = acytail * bcx;
  c = splitter * acytail;
  ahi = c - (c - acytail);
  alo = acytail - ahi;
  c = splitter * bcx;
  bhi = c - (c - bcx);
  blo = bcx - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  u[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  u[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u32 = _j + _i;
  bvirt = u32 - _j;
  u[2] = _j - (u32 - bvirt) + (_i - bvirt);
  u[3] = u32;
  const C1len = sum(4, B, 4, u, C1);
  s1 = acx * bcytail;
  c = splitter * acx;
  ahi = c - (c - acx);
  alo = acx - ahi;
  c = splitter * bcytail;
  bhi = c - (c - bcytail);
  blo = bcytail - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = acy * bcxtail;
  c = splitter * acy;
  ahi = c - (c - acy);
  alo = acy - ahi;
  c = splitter * bcxtail;
  bhi = c - (c - bcxtail);
  blo = bcxtail - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  u[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  u[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u32 = _j + _i;
  bvirt = u32 - _j;
  u[2] = _j - (u32 - bvirt) + (_i - bvirt);
  u[3] = u32;
  const C2len = sum(C1len, C1, 4, u, C2);
  s1 = acxtail * bcytail;
  c = splitter * acxtail;
  ahi = c - (c - acxtail);
  alo = acxtail - ahi;
  c = splitter * bcytail;
  bhi = c - (c - bcytail);
  blo = bcytail - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = acytail * bcxtail;
  c = splitter * acytail;
  ahi = c - (c - acytail);
  alo = acytail - ahi;
  c = splitter * bcxtail;
  bhi = c - (c - bcxtail);
  blo = bcxtail - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  u[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  u[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u32 = _j + _i;
  bvirt = u32 - _j;
  u[2] = _j - (u32 - bvirt) + (_i - bvirt);
  u[3] = u32;
  const Dlen = sum(C2len, C2, 4, u, D);
  return D[Dlen - 1];
}
function orient2d(ax, ay, bx, by, cx, cy) {
  const detleft = (ay - cy) * (bx - cx);
  const detright = (ax - cx) * (by - cy);
  const det = detleft - detright;
  const detsum = Math.abs(detleft + detright);
  if (Math.abs(det) >= ccwerrboundA * detsum) return det;
  return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);
}

// node_modules/robust-predicates/esm/orient3d.js
var o3derrboundA = (7 + 56 * epsilon) * epsilon;
var o3derrboundB = (3 + 28 * epsilon) * epsilon;
var o3derrboundC = (26 + 288 * epsilon) * epsilon * epsilon;
var bc = vec(4);
var ca = vec(4);
var ab = vec(4);
var at_b = vec(4);
var at_c = vec(4);
var bt_c = vec(4);
var bt_a = vec(4);
var ct_a = vec(4);
var ct_b = vec(4);
var bct = vec(8);
var cat = vec(8);
var abt = vec(8);
var u2 = vec(4);
var _8 = vec(8);
var _8b = vec(8);
var _16 = vec(8);
var _12 = vec(12);
var fin = vec(192);
var fin2 = vec(192);

// node_modules/robust-predicates/esm/incircle.js
var iccerrboundA = (10 + 96 * epsilon) * epsilon;
var iccerrboundB = (4 + 48 * epsilon) * epsilon;
var iccerrboundC = (44 + 576 * epsilon) * epsilon * epsilon;
var bc2 = vec(4);
var ca2 = vec(4);
var ab2 = vec(4);
var aa = vec(4);
var bb = vec(4);
var cc = vec(4);
var u3 = vec(4);
var v = vec(4);
var axtbc = vec(8);
var aytbc = vec(8);
var bxtca = vec(8);
var bytca = vec(8);
var cxtab = vec(8);
var cytab = vec(8);
var abt2 = vec(8);
var bct2 = vec(8);
var cat2 = vec(8);
var abtt = vec(4);
var bctt = vec(4);
var catt = vec(4);
var _82 = vec(8);
var _162 = vec(16);
var _16b = vec(16);
var _16c = vec(16);
var _32 = vec(32);
var _32b = vec(32);
var _48 = vec(48);
var _64 = vec(64);
var fin3 = vec(1152);
var fin22 = vec(1152);

// node_modules/robust-predicates/esm/insphere.js
var isperrboundA = (16 + 224 * epsilon) * epsilon;
var isperrboundB = (5 + 72 * epsilon) * epsilon;
var isperrboundC = (71 + 1408 * epsilon) * epsilon * epsilon;
var ab3 = vec(4);
var bc3 = vec(4);
var cd = vec(4);
var de = vec(4);
var ea = vec(4);
var ac = vec(4);
var bd = vec(4);
var ce = vec(4);
var da = vec(4);
var eb = vec(4);
var abc = vec(24);
var bcd = vec(24);
var cde = vec(24);
var dea = vec(24);
var eab = vec(24);
var abd = vec(24);
var bce = vec(24);
var cda = vec(24);
var deb = vec(24);
var eac = vec(24);
var adet = vec(1152);
var bdet = vec(1152);
var cdet = vec(1152);
var ddet = vec(1152);
var edet = vec(1152);
var abdet = vec(2304);
var cddet = vec(2304);
var cdedet = vec(3456);
var deter = vec(5760);
var _83 = vec(8);
var _8b2 = vec(8);
var _8c = vec(8);
var _163 = vec(16);
var _24 = vec(24);
var _482 = vec(48);
var _48b = vec(48);
var _96 = vec(96);
var _192 = vec(192);
var _384x = vec(384);
var _384y = vec(384);
var _384z = vec(384);
var _768 = vec(768);
var xdet = vec(96);
var ydet = vec(96);
var zdet = vec(96);
var fin4 = vec(1152);

// node_modules/delaunator/index.js
var EPSILON = Math.pow(2, -52);
var EDGE_STACK = new Uint32Array(512);
var Delaunator = class _Delaunator {
  static from(points, getX = defaultGetX, getY = defaultGetY) {
    const n2 = points.length;
    const coords = new Float64Array(n2 * 2);
    for (let i2 = 0; i2 < n2; i2++) {
      const p = points[i2];
      coords[2 * i2] = getX(p);
      coords[2 * i2 + 1] = getY(p);
    }
    return new _Delaunator(coords);
  }
  constructor(coords) {
    const n2 = coords.length >> 1;
    if (n2 > 0 && typeof coords[0] !== "number") throw new Error("Expected coords to contain numbers.");
    this.coords = coords;
    const maxTriangles = Math.max(2 * n2 - 5, 0);
    this._triangles = new Uint32Array(maxTriangles * 3);
    this._halfedges = new Int32Array(maxTriangles * 3);
    this._hashSize = Math.ceil(Math.sqrt(n2));
    this._hullPrev = new Uint32Array(n2);
    this._hullNext = new Uint32Array(n2);
    this._hullTri = new Uint32Array(n2);
    this._hullHash = new Int32Array(this._hashSize);
    this._ids = new Uint32Array(n2);
    this._dists = new Float64Array(n2);
    this.update();
  }
  update() {
    const { coords, _hullPrev: hullPrev, _hullNext: hullNext, _hullTri: hullTri, _hullHash: hullHash } = this;
    const n2 = coords.length >> 1;
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    for (let i3 = 0; i3 < n2; i3++) {
      const x2 = coords[2 * i3];
      const y2 = coords[2 * i3 + 1];
      if (x2 < minX) minX = x2;
      if (y2 < minY) minY = y2;
      if (x2 > maxX) maxX = x2;
      if (y2 > maxY) maxY = y2;
      this._ids[i3] = i3;
    }
    const cx = (minX + maxX) / 2;
    const cy = (minY + maxY) / 2;
    let i0, i1, i2;
    for (let i3 = 0, minDist = Infinity; i3 < n2; i3++) {
      const d = dist(cx, cy, coords[2 * i3], coords[2 * i3 + 1]);
      if (d < minDist) {
        i0 = i3;
        minDist = d;
      }
    }
    const i0x = coords[2 * i0];
    const i0y = coords[2 * i0 + 1];
    for (let i3 = 0, minDist = Infinity; i3 < n2; i3++) {
      if (i3 === i0) continue;
      const d = dist(i0x, i0y, coords[2 * i3], coords[2 * i3 + 1]);
      if (d < minDist && d > 0) {
        i1 = i3;
        minDist = d;
      }
    }
    let i1x = coords[2 * i1];
    let i1y = coords[2 * i1 + 1];
    let minRadius = Infinity;
    for (let i3 = 0; i3 < n2; i3++) {
      if (i3 === i0 || i3 === i1) continue;
      const r2 = circumradius(i0x, i0y, i1x, i1y, coords[2 * i3], coords[2 * i3 + 1]);
      if (r2 < minRadius) {
        i2 = i3;
        minRadius = r2;
      }
    }
    let i2x = coords[2 * i2];
    let i2y = coords[2 * i2 + 1];
    if (minRadius === Infinity) {
      for (let i3 = 0; i3 < n2; i3++) {
        this._dists[i3] = coords[2 * i3] - coords[0] || coords[2 * i3 + 1] - coords[1];
      }
      quicksort(this._ids, this._dists, 0, n2 - 1);
      const hull = new Uint32Array(n2);
      let j2 = 0;
      for (let i3 = 0, d0 = -Infinity; i3 < n2; i3++) {
        const id = this._ids[i3];
        const d = this._dists[id];
        if (d > d0) {
          hull[j2++] = id;
          d0 = d;
        }
      }
      this.hull = hull.subarray(0, j2);
      this.triangles = new Uint32Array(0);
      this.halfedges = new Uint32Array(0);
      return;
    }
    if (orient2d(i0x, i0y, i1x, i1y, i2x, i2y) < 0) {
      const i3 = i1;
      const x2 = i1x;
      const y2 = i1y;
      i1 = i2;
      i1x = i2x;
      i1y = i2y;
      i2 = i3;
      i2x = x2;
      i2y = y2;
    }
    const center = circumcenter(i0x, i0y, i1x, i1y, i2x, i2y);
    this._cx = center.x;
    this._cy = center.y;
    for (let i3 = 0; i3 < n2; i3++) {
      this._dists[i3] = dist(coords[2 * i3], coords[2 * i3 + 1], center.x, center.y);
    }
    quicksort(this._ids, this._dists, 0, n2 - 1);
    this._hullStart = i0;
    let hullSize = 3;
    hullNext[i0] = hullPrev[i2] = i1;
    hullNext[i1] = hullPrev[i0] = i2;
    hullNext[i2] = hullPrev[i1] = i0;
    hullTri[i0] = 0;
    hullTri[i1] = 1;
    hullTri[i2] = 2;
    hullHash.fill(-1);
    hullHash[this._hashKey(i0x, i0y)] = i0;
    hullHash[this._hashKey(i1x, i1y)] = i1;
    hullHash[this._hashKey(i2x, i2y)] = i2;
    this.trianglesLen = 0;
    this._addTriangle(i0, i1, i2, -1, -1, -1);
    for (let k2 = 0, xp, yp; k2 < this._ids.length; k2++) {
      const i3 = this._ids[k2];
      const x2 = coords[2 * i3];
      const y2 = coords[2 * i3 + 1];
      if (k2 > 0 && Math.abs(x2 - xp) <= EPSILON && Math.abs(y2 - yp) <= EPSILON) continue;
      xp = x2;
      yp = y2;
      if (i3 === i0 || i3 === i1 || i3 === i2) continue;
      let start = 0;
      for (let j2 = 0, key = this._hashKey(x2, y2); j2 < this._hashSize; j2++) {
        start = hullHash[(key + j2) % this._hashSize];
        if (start !== -1 && start !== hullNext[start]) break;
      }
      start = hullPrev[start];
      let e2 = start, q2;
      while (q2 = hullNext[e2], orient2d(x2, y2, coords[2 * e2], coords[2 * e2 + 1], coords[2 * q2], coords[2 * q2 + 1]) >= 0) {
        e2 = q2;
        if (e2 === start) {
          e2 = -1;
          break;
        }
      }
      if (e2 === -1) continue;
      let t2 = this._addTriangle(e2, i3, hullNext[e2], -1, -1, hullTri[e2]);
      hullTri[i3] = this._legalize(t2 + 2);
      hullTri[e2] = t2;
      hullSize++;
      let n3 = hullNext[e2];
      while (q2 = hullNext[n3], orient2d(x2, y2, coords[2 * n3], coords[2 * n3 + 1], coords[2 * q2], coords[2 * q2 + 1]) < 0) {
        t2 = this._addTriangle(n3, i3, q2, hullTri[i3], -1, hullTri[n3]);
        hullTri[i3] = this._legalize(t2 + 2);
        hullNext[n3] = n3;
        hullSize--;
        n3 = q2;
      }
      if (e2 === start) {
        while (q2 = hullPrev[e2], orient2d(x2, y2, coords[2 * q2], coords[2 * q2 + 1], coords[2 * e2], coords[2 * e2 + 1]) < 0) {
          t2 = this._addTriangle(q2, i3, e2, -1, hullTri[e2], hullTri[q2]);
          this._legalize(t2 + 2);
          hullTri[q2] = t2;
          hullNext[e2] = e2;
          hullSize--;
          e2 = q2;
        }
      }
      this._hullStart = hullPrev[i3] = e2;
      hullNext[e2] = hullPrev[n3] = i3;
      hullNext[i3] = n3;
      hullHash[this._hashKey(x2, y2)] = i3;
      hullHash[this._hashKey(coords[2 * e2], coords[2 * e2 + 1])] = e2;
    }
    this.hull = new Uint32Array(hullSize);
    for (let i3 = 0, e2 = this._hullStart; i3 < hullSize; i3++) {
      this.hull[i3] = e2;
      e2 = hullNext[e2];
    }
    this.triangles = this._triangles.subarray(0, this.trianglesLen);
    this.halfedges = this._halfedges.subarray(0, this.trianglesLen);
  }
  _hashKey(x2, y2) {
    return Math.floor(pseudoAngle(x2 - this._cx, y2 - this._cy) * this._hashSize) % this._hashSize;
  }
  _legalize(a) {
    const { _triangles: triangles, _halfedges: halfedges, coords } = this;
    let i2 = 0;
    let ar = 0;
    while (true) {
      const b2 = halfedges[a];
      const a0 = a - a % 3;
      ar = a0 + (a + 2) % 3;
      if (b2 === -1) {
        if (i2 === 0) break;
        a = EDGE_STACK[--i2];
        continue;
      }
      const b0 = b2 - b2 % 3;
      const al = a0 + (a + 1) % 3;
      const bl = b0 + (b2 + 2) % 3;
      const p0 = triangles[ar];
      const pr = triangles[a];
      const pl = triangles[al];
      const p1 = triangles[bl];
      const illegal = inCircle(
        coords[2 * p0],
        coords[2 * p0 + 1],
        coords[2 * pr],
        coords[2 * pr + 1],
        coords[2 * pl],
        coords[2 * pl + 1],
        coords[2 * p1],
        coords[2 * p1 + 1]
      );
      if (illegal) {
        triangles[a] = p1;
        triangles[b2] = p0;
        const hbl = halfedges[bl];
        if (hbl === -1) {
          let e2 = this._hullStart;
          do {
            if (this._hullTri[e2] === bl) {
              this._hullTri[e2] = a;
              break;
            }
            e2 = this._hullPrev[e2];
          } while (e2 !== this._hullStart);
        }
        this._link(a, hbl);
        this._link(b2, halfedges[ar]);
        this._link(ar, bl);
        const br = b0 + (b2 + 1) % 3;
        if (i2 < EDGE_STACK.length) {
          EDGE_STACK[i2++] = br;
        }
      } else {
        if (i2 === 0) break;
        a = EDGE_STACK[--i2];
      }
    }
    return ar;
  }
  _link(a, b2) {
    this._halfedges[a] = b2;
    if (b2 !== -1) this._halfedges[b2] = a;
  }
  // add a new triangle given vertex indices and adjacent half-edge ids
  _addTriangle(i0, i1, i2, a, b2, c) {
    const t2 = this.trianglesLen;
    this._triangles[t2] = i0;
    this._triangles[t2 + 1] = i1;
    this._triangles[t2 + 2] = i2;
    this._link(t2, a);
    this._link(t2 + 1, b2);
    this._link(t2 + 2, c);
    this.trianglesLen += 3;
    return t2;
  }
};
function pseudoAngle(dx, dy) {
  const p = dx / (Math.abs(dx) + Math.abs(dy));
  return (dy > 0 ? 3 - p : 1 + p) / 4;
}
function dist(ax, ay, bx, by) {
  const dx = ax - bx;
  const dy = ay - by;
  return dx * dx + dy * dy;
}
function inCircle(ax, ay, bx, by, cx, cy, px, py) {
  const dx = ax - px;
  const dy = ay - py;
  const ex = bx - px;
  const ey = by - py;
  const fx = cx - px;
  const fy = cy - py;
  const ap = dx * dx + dy * dy;
  const bp = ex * ex + ey * ey;
  const cp = fx * fx + fy * fy;
  return dx * (ey * cp - bp * fy) - dy * (ex * cp - bp * fx) + ap * (ex * fy - ey * fx) < 0;
}
function circumradius(ax, ay, bx, by, cx, cy) {
  const dx = bx - ax;
  const dy = by - ay;
  const ex = cx - ax;
  const ey = cy - ay;
  const bl = dx * dx + dy * dy;
  const cl = ex * ex + ey * ey;
  const d = 0.5 / (dx * ey - dy * ex);
  const x2 = (ey * bl - dy * cl) * d;
  const y2 = (dx * cl - ex * bl) * d;
  return x2 * x2 + y2 * y2;
}
function circumcenter(ax, ay, bx, by, cx, cy) {
  const dx = bx - ax;
  const dy = by - ay;
  const ex = cx - ax;
  const ey = cy - ay;
  const bl = dx * dx + dy * dy;
  const cl = ex * ex + ey * ey;
  const d = 0.5 / (dx * ey - dy * ex);
  const x2 = ax + (ey * bl - dy * cl) * d;
  const y2 = ay + (dx * cl - ex * bl) * d;
  return { x: x2, y: y2 };
}
function quicksort(ids, dists, left, right) {
  if (right - left <= 20) {
    for (let i2 = left + 1; i2 <= right; i2++) {
      const temp = ids[i2];
      const tempDist = dists[temp];
      let j2 = i2 - 1;
      while (j2 >= left && dists[ids[j2]] > tempDist) ids[j2 + 1] = ids[j2--];
      ids[j2 + 1] = temp;
    }
  } else {
    const median = left + right >> 1;
    let i2 = left + 1;
    let j2 = right;
    swap(ids, median, i2);
    if (dists[ids[left]] > dists[ids[right]]) swap(ids, left, right);
    if (dists[ids[i2]] > dists[ids[right]]) swap(ids, i2, right);
    if (dists[ids[left]] > dists[ids[i2]]) swap(ids, left, i2);
    const temp = ids[i2];
    const tempDist = dists[temp];
    while (true) {
      do
        i2++;
      while (dists[ids[i2]] < tempDist);
      do
        j2--;
      while (dists[ids[j2]] > tempDist);
      if (j2 < i2) break;
      swap(ids, i2, j2);
    }
    ids[left + 1] = ids[j2];
    ids[j2] = temp;
    if (right - i2 + 1 >= j2 - left) {
      quicksort(ids, dists, i2, right);
      quicksort(ids, dists, left, j2 - 1);
    } else {
      quicksort(ids, dists, left, j2 - 1);
      quicksort(ids, dists, i2, right);
    }
  }
}
function swap(arr, i2, j2) {
  const tmp = arr[i2];
  arr[i2] = arr[j2];
  arr[j2] = tmp;
}
function defaultGetX(p) {
  return p[0];
}
function defaultGetY(p) {
  return p[1];
}

// node_modules/d3-delaunay/src/path.js
var epsilon2 = 1e-6;
var Path = class {
  constructor() {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null;
    this._ = "";
  }
  moveTo(x2, y2) {
    this._ += `M${this._x0 = this._x1 = +x2},${this._y0 = this._y1 = +y2}`;
  }
  closePath() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  }
  lineTo(x2, y2) {
    this._ += `L${this._x1 = +x2},${this._y1 = +y2}`;
  }
  arc(x2, y2, r2) {
    x2 = +x2, y2 = +y2, r2 = +r2;
    const x0 = x2 + r2;
    const y0 = y2;
    if (r2 < 0) throw new Error("negative radius");
    if (this._x1 === null) this._ += `M${x0},${y0}`;
    else if (Math.abs(this._x1 - x0) > epsilon2 || Math.abs(this._y1 - y0) > epsilon2) this._ += "L" + x0 + "," + y0;
    if (!r2) return;
    this._ += `A${r2},${r2},0,1,1,${x2 - r2},${y2}A${r2},${r2},0,1,1,${this._x1 = x0},${this._y1 = y0}`;
  }
  rect(x2, y2, w2, h) {
    this._ += `M${this._x0 = this._x1 = +x2},${this._y0 = this._y1 = +y2}h${+w2}v${+h}h${-w2}Z`;
  }
  value() {
    return this._ || null;
  }
};

// node_modules/d3-delaunay/src/polygon.js
var Polygon = class {
  constructor() {
    this._ = [];
  }
  moveTo(x2, y2) {
    this._.push([x2, y2]);
  }
  closePath() {
    this._.push(this._[0].slice());
  }
  lineTo(x2, y2) {
    this._.push([x2, y2]);
  }
  value() {
    return this._.length ? this._ : null;
  }
};

// node_modules/d3-delaunay/src/voronoi.js
var Voronoi = class {
  constructor(delaunay, [xmin, ymin, xmax, ymax] = [0, 0, 960, 500]) {
    if (!((xmax = +xmax) >= (xmin = +xmin)) || !((ymax = +ymax) >= (ymin = +ymin))) throw new Error("invalid bounds");
    this.delaunay = delaunay;
    this._circumcenters = new Float64Array(delaunay.points.length * 2);
    this.vectors = new Float64Array(delaunay.points.length * 2);
    this.xmax = xmax, this.xmin = xmin;
    this.ymax = ymax, this.ymin = ymin;
    this._init();
  }
  update() {
    this.delaunay.update();
    this._init();
    return this;
  }
  _init() {
    const { delaunay: { points, hull, triangles }, vectors } = this;
    let bx, by;
    const circumcenters = this.circumcenters = this._circumcenters.subarray(0, triangles.length / 3 * 2);
    for (let i2 = 0, j2 = 0, n2 = triangles.length, x2, y2; i2 < n2; i2 += 3, j2 += 2) {
      const t1 = triangles[i2] * 2;
      const t2 = triangles[i2 + 1] * 2;
      const t3 = triangles[i2 + 2] * 2;
      const x12 = points[t1];
      const y12 = points[t1 + 1];
      const x22 = points[t2];
      const y22 = points[t2 + 1];
      const x3 = points[t3];
      const y3 = points[t3 + 1];
      const dx = x22 - x12;
      const dy = y22 - y12;
      const ex = x3 - x12;
      const ey = y3 - y12;
      const ab4 = (dx * ey - dy * ex) * 2;
      if (Math.abs(ab4) < 1e-9) {
        if (bx === void 0) {
          bx = by = 0;
          for (const i3 of hull) bx += points[i3 * 2], by += points[i3 * 2 + 1];
          bx /= hull.length, by /= hull.length;
        }
        const a = 1e9 * Math.sign((bx - x12) * ey - (by - y12) * ex);
        x2 = (x12 + x3) / 2 - a * ey;
        y2 = (y12 + y3) / 2 + a * ex;
      } else {
        const d = 1 / ab4;
        const bl = dx * dx + dy * dy;
        const cl = ex * ex + ey * ey;
        x2 = x12 + (ey * bl - dy * cl) * d;
        y2 = y12 + (dx * cl - ex * bl) * d;
      }
      circumcenters[j2] = x2;
      circumcenters[j2 + 1] = y2;
    }
    let h = hull[hull.length - 1];
    let p0, p1 = h * 4;
    let x0, x1 = points[2 * h];
    let y0, y1 = points[2 * h + 1];
    vectors.fill(0);
    for (let i2 = 0; i2 < hull.length; ++i2) {
      h = hull[i2];
      p0 = p1, x0 = x1, y0 = y1;
      p1 = h * 4, x1 = points[2 * h], y1 = points[2 * h + 1];
      vectors[p0 + 2] = vectors[p1] = y0 - y1;
      vectors[p0 + 3] = vectors[p1 + 1] = x1 - x0;
    }
  }
  render(context) {
    const buffer = context == null ? context = new Path() : void 0;
    const { delaunay: { halfedges, inedges, hull }, circumcenters, vectors } = this;
    if (hull.length <= 1) return null;
    for (let i2 = 0, n2 = halfedges.length; i2 < n2; ++i2) {
      const j2 = halfedges[i2];
      if (j2 < i2) continue;
      const ti = Math.floor(i2 / 3) * 2;
      const tj = Math.floor(j2 / 3) * 2;
      const xi = circumcenters[ti];
      const yi = circumcenters[ti + 1];
      const xj = circumcenters[tj];
      const yj = circumcenters[tj + 1];
      this._renderSegment(xi, yi, xj, yj, context);
    }
    let h0, h1 = hull[hull.length - 1];
    for (let i2 = 0; i2 < hull.length; ++i2) {
      h0 = h1, h1 = hull[i2];
      const t2 = Math.floor(inedges[h1] / 3) * 2;
      const x2 = circumcenters[t2];
      const y2 = circumcenters[t2 + 1];
      const v2 = h0 * 4;
      const p = this._project(x2, y2, vectors[v2 + 2], vectors[v2 + 3]);
      if (p) this._renderSegment(x2, y2, p[0], p[1], context);
    }
    return buffer && buffer.value();
  }
  renderBounds(context) {
    const buffer = context == null ? context = new Path() : void 0;
    context.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin);
    return buffer && buffer.value();
  }
  renderCell(i2, context) {
    const buffer = context == null ? context = new Path() : void 0;
    const points = this._clip(i2);
    if (points === null || !points.length) return;
    context.moveTo(points[0], points[1]);
    let n2 = points.length;
    while (points[0] === points[n2 - 2] && points[1] === points[n2 - 1] && n2 > 1) n2 -= 2;
    for (let i3 = 2; i3 < n2; i3 += 2) {
      if (points[i3] !== points[i3 - 2] || points[i3 + 1] !== points[i3 - 1])
        context.lineTo(points[i3], points[i3 + 1]);
    }
    context.closePath();
    return buffer && buffer.value();
  }
  *cellPolygons() {
    const { delaunay: { points } } = this;
    for (let i2 = 0, n2 = points.length / 2; i2 < n2; ++i2) {
      const cell = this.cellPolygon(i2);
      if (cell) cell.index = i2, yield cell;
    }
  }
  cellPolygon(i2) {
    const polygon = new Polygon();
    this.renderCell(i2, polygon);
    return polygon.value();
  }
  _renderSegment(x0, y0, x1, y1, context) {
    let S2;
    const c0 = this._regioncode(x0, y0);
    const c1 = this._regioncode(x1, y1);
    if (c0 === 0 && c1 === 0) {
      context.moveTo(x0, y0);
      context.lineTo(x1, y1);
    } else if (S2 = this._clipSegment(x0, y0, x1, y1, c0, c1)) {
      context.moveTo(S2[0], S2[1]);
      context.lineTo(S2[2], S2[3]);
    }
  }
  contains(i2, x2, y2) {
    if ((x2 = +x2, x2 !== x2) || (y2 = +y2, y2 !== y2)) return false;
    return this.delaunay._step(i2, x2, y2) === i2;
  }
  *neighbors(i2) {
    const ci = this._clip(i2);
    if (ci) for (const j2 of this.delaunay.neighbors(i2)) {
      const cj = this._clip(j2);
      if (cj) loop: for (let ai = 0, li = ci.length; ai < li; ai += 2) {
        for (let aj = 0, lj = cj.length; aj < lj; aj += 2) {
          if (ci[ai] === cj[aj] && ci[ai + 1] === cj[aj + 1] && ci[(ai + 2) % li] === cj[(aj + lj - 2) % lj] && ci[(ai + 3) % li] === cj[(aj + lj - 1) % lj]) {
            yield j2;
            break loop;
          }
        }
      }
    }
  }
  _cell(i2) {
    const { circumcenters, delaunay: { inedges, halfedges, triangles } } = this;
    const e0 = inedges[i2];
    if (e0 === -1) return null;
    const points = [];
    let e2 = e0;
    do {
      const t2 = Math.floor(e2 / 3);
      points.push(circumcenters[t2 * 2], circumcenters[t2 * 2 + 1]);
      e2 = e2 % 3 === 2 ? e2 - 2 : e2 + 1;
      if (triangles[e2] !== i2) break;
      e2 = halfedges[e2];
    } while (e2 !== e0 && e2 !== -1);
    return points;
  }
  _clip(i2) {
    if (i2 === 0 && this.delaunay.hull.length === 1) {
      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
    }
    const points = this._cell(i2);
    if (points === null) return null;
    const { vectors: V } = this;
    const v2 = i2 * 4;
    return this._simplify(V[v2] || V[v2 + 1] ? this._clipInfinite(i2, points, V[v2], V[v2 + 1], V[v2 + 2], V[v2 + 3]) : this._clipFinite(i2, points));
  }
  _clipFinite(i2, points) {
    const n2 = points.length;
    let P2 = null;
    let x0, y0, x1 = points[n2 - 2], y1 = points[n2 - 1];
    let c0, c1 = this._regioncode(x1, y1);
    let e0, e1 = 0;
    for (let j2 = 0; j2 < n2; j2 += 2) {
      x0 = x1, y0 = y1, x1 = points[j2], y1 = points[j2 + 1];
      c0 = c1, c1 = this._regioncode(x1, y1);
      if (c0 === 0 && c1 === 0) {
        e0 = e1, e1 = 0;
        if (P2) P2.push(x1, y1);
        else P2 = [x1, y1];
      } else {
        let S2, sx0, sy0, sx1, sy1;
        if (c0 === 0) {
          if ((S2 = this._clipSegment(x0, y0, x1, y1, c0, c1)) === null) continue;
          [sx0, sy0, sx1, sy1] = S2;
        } else {
          if ((S2 = this._clipSegment(x1, y1, x0, y0, c1, c0)) === null) continue;
          [sx1, sy1, sx0, sy0] = S2;
          e0 = e1, e1 = this._edgecode(sx0, sy0);
          if (e0 && e1) this._edge(i2, e0, e1, P2, P2.length);
          if (P2) P2.push(sx0, sy0);
          else P2 = [sx0, sy0];
        }
        e0 = e1, e1 = this._edgecode(sx1, sy1);
        if (e0 && e1) this._edge(i2, e0, e1, P2, P2.length);
        if (P2) P2.push(sx1, sy1);
        else P2 = [sx1, sy1];
      }
    }
    if (P2) {
      e0 = e1, e1 = this._edgecode(P2[0], P2[1]);
      if (e0 && e1) this._edge(i2, e0, e1, P2, P2.length);
    } else if (this.contains(i2, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
    }
    return P2;
  }
  _clipSegment(x0, y0, x1, y1, c0, c1) {
    const flip = c0 < c1;
    if (flip) [x0, y0, x1, y1, c0, c1] = [x1, y1, x0, y0, c1, c0];
    while (true) {
      if (c0 === 0 && c1 === 0) return flip ? [x1, y1, x0, y0] : [x0, y0, x1, y1];
      if (c0 & c1) return null;
      let x2, y2, c = c0 || c1;
      if (c & 8) x2 = x0 + (x1 - x0) * (this.ymax - y0) / (y1 - y0), y2 = this.ymax;
      else if (c & 4) x2 = x0 + (x1 - x0) * (this.ymin - y0) / (y1 - y0), y2 = this.ymin;
      else if (c & 2) y2 = y0 + (y1 - y0) * (this.xmax - x0) / (x1 - x0), x2 = this.xmax;
      else y2 = y0 + (y1 - y0) * (this.xmin - x0) / (x1 - x0), x2 = this.xmin;
      if (c0) x0 = x2, y0 = y2, c0 = this._regioncode(x0, y0);
      else x1 = x2, y1 = y2, c1 = this._regioncode(x1, y1);
    }
  }
  _clipInfinite(i2, points, vx0, vy0, vxn, vyn) {
    let P2 = Array.from(points), p;
    if (p = this._project(P2[0], P2[1], vx0, vy0)) P2.unshift(p[0], p[1]);
    if (p = this._project(P2[P2.length - 2], P2[P2.length - 1], vxn, vyn)) P2.push(p[0], p[1]);
    if (P2 = this._clipFinite(i2, P2)) {
      for (let j2 = 0, n2 = P2.length, c0, c1 = this._edgecode(P2[n2 - 2], P2[n2 - 1]); j2 < n2; j2 += 2) {
        c0 = c1, c1 = this._edgecode(P2[j2], P2[j2 + 1]);
        if (c0 && c1) j2 = this._edge(i2, c0, c1, P2, j2), n2 = P2.length;
      }
    } else if (this.contains(i2, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
      P2 = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax];
    }
    return P2;
  }
  _edge(i2, e0, e1, P2, j2) {
    while (e0 !== e1) {
      let x2, y2;
      switch (e0) {
        case 5:
          e0 = 4;
          continue;
        case 4:
          e0 = 6, x2 = this.xmax, y2 = this.ymin;
          break;
        case 6:
          e0 = 2;
          continue;
        case 2:
          e0 = 10, x2 = this.xmax, y2 = this.ymax;
          break;
        case 10:
          e0 = 8;
          continue;
        case 8:
          e0 = 9, x2 = this.xmin, y2 = this.ymax;
          break;
        case 9:
          e0 = 1;
          continue;
        case 1:
          e0 = 5, x2 = this.xmin, y2 = this.ymin;
          break;
      }
      if ((P2[j2] !== x2 || P2[j2 + 1] !== y2) && this.contains(i2, x2, y2)) {
        P2.splice(j2, 0, x2, y2), j2 += 2;
      }
    }
    return j2;
  }
  _project(x0, y0, vx, vy) {
    let t2 = Infinity, c, x2, y2;
    if (vy < 0) {
      if (y0 <= this.ymin) return null;
      if ((c = (this.ymin - y0) / vy) < t2) y2 = this.ymin, x2 = x0 + (t2 = c) * vx;
    } else if (vy > 0) {
      if (y0 >= this.ymax) return null;
      if ((c = (this.ymax - y0) / vy) < t2) y2 = this.ymax, x2 = x0 + (t2 = c) * vx;
    }
    if (vx > 0) {
      if (x0 >= this.xmax) return null;
      if ((c = (this.xmax - x0) / vx) < t2) x2 = this.xmax, y2 = y0 + (t2 = c) * vy;
    } else if (vx < 0) {
      if (x0 <= this.xmin) return null;
      if ((c = (this.xmin - x0) / vx) < t2) x2 = this.xmin, y2 = y0 + (t2 = c) * vy;
    }
    return [x2, y2];
  }
  _edgecode(x2, y2) {
    return (x2 === this.xmin ? 1 : x2 === this.xmax ? 2 : 0) | (y2 === this.ymin ? 4 : y2 === this.ymax ? 8 : 0);
  }
  _regioncode(x2, y2) {
    return (x2 < this.xmin ? 1 : x2 > this.xmax ? 2 : 0) | (y2 < this.ymin ? 4 : y2 > this.ymax ? 8 : 0);
  }
  _simplify(P2) {
    if (P2 && P2.length > 4) {
      for (let i2 = 0; i2 < P2.length; i2 += 2) {
        const j2 = (i2 + 2) % P2.length, k2 = (i2 + 4) % P2.length;
        if (P2[i2] === P2[j2] && P2[j2] === P2[k2] || P2[i2 + 1] === P2[j2 + 1] && P2[j2 + 1] === P2[k2 + 1]) {
          P2.splice(j2, 2), i2 -= 2;
        }
      }
      if (!P2.length) P2 = null;
    }
    return P2;
  }
};

// node_modules/d3-delaunay/src/delaunay.js
var tau = 2 * Math.PI;
var pow = Math.pow;
function pointX(p) {
  return p[0];
}
function pointY(p) {
  return p[1];
}
function collinear(d) {
  const { triangles, coords } = d;
  for (let i2 = 0; i2 < triangles.length; i2 += 3) {
    const a = 2 * triangles[i2], b2 = 2 * triangles[i2 + 1], c = 2 * triangles[i2 + 2], cross = (coords[c] - coords[a]) * (coords[b2 + 1] - coords[a + 1]) - (coords[b2] - coords[a]) * (coords[c + 1] - coords[a + 1]);
    if (cross > 1e-10) return false;
  }
  return true;
}
function jitter(x2, y2, r2) {
  return [x2 + Math.sin(x2 + y2) * r2, y2 + Math.cos(x2 - y2) * r2];
}
var Delaunay = class _Delaunay {
  static from(points, fx = pointX, fy = pointY, that) {
    return new _Delaunay("length" in points ? flatArray(points, fx, fy, that) : Float64Array.from(flatIterable(points, fx, fy, that)));
  }
  constructor(points) {
    this._delaunator = new Delaunator(points);
    this.inedges = new Int32Array(points.length / 2);
    this._hullIndex = new Int32Array(points.length / 2);
    this.points = this._delaunator.coords;
    this._init();
  }
  update() {
    this._delaunator.update();
    this._init();
    return this;
  }
  _init() {
    const d = this._delaunator, points = this.points;
    if (d.hull && d.hull.length > 2 && collinear(d)) {
      this.collinear = Int32Array.from({ length: points.length / 2 }, (_, i2) => i2).sort((i2, j2) => points[2 * i2] - points[2 * j2] || points[2 * i2 + 1] - points[2 * j2 + 1]);
      const e2 = this.collinear[0], f = this.collinear[this.collinear.length - 1], bounds = [points[2 * e2], points[2 * e2 + 1], points[2 * f], points[2 * f + 1]], r2 = 1e-8 * Math.hypot(bounds[3] - bounds[1], bounds[2] - bounds[0]);
      for (let i2 = 0, n2 = points.length / 2; i2 < n2; ++i2) {
        const p = jitter(points[2 * i2], points[2 * i2 + 1], r2);
        points[2 * i2] = p[0];
        points[2 * i2 + 1] = p[1];
      }
      this._delaunator = new Delaunator(points);
    } else {
      delete this.collinear;
    }
    const halfedges = this.halfedges = this._delaunator.halfedges;
    const hull = this.hull = this._delaunator.hull;
    const triangles = this.triangles = this._delaunator.triangles;
    const inedges = this.inedges.fill(-1);
    const hullIndex = this._hullIndex.fill(-1);
    for (let e2 = 0, n2 = halfedges.length; e2 < n2; ++e2) {
      const p = triangles[e2 % 3 === 2 ? e2 - 2 : e2 + 1];
      if (halfedges[e2] === -1 || inedges[p] === -1) inedges[p] = e2;
    }
    for (let i2 = 0, n2 = hull.length; i2 < n2; ++i2) {
      hullIndex[hull[i2]] = i2;
    }
    if (hull.length <= 2 && hull.length > 0) {
      this.triangles = new Int32Array(3).fill(-1);
      this.halfedges = new Int32Array(3).fill(-1);
      this.triangles[0] = hull[0];
      inedges[hull[0]] = 1;
      if (hull.length === 2) {
        inedges[hull[1]] = 0;
        this.triangles[1] = hull[1];
        this.triangles[2] = hull[1];
      }
    }
  }
  voronoi(bounds) {
    return new Voronoi(this, bounds);
  }
  *neighbors(i2) {
    const { inedges, hull, _hullIndex, halfedges, triangles, collinear: collinear2 } = this;
    if (collinear2) {
      const l2 = collinear2.indexOf(i2);
      if (l2 > 0) yield collinear2[l2 - 1];
      if (l2 < collinear2.length - 1) yield collinear2[l2 + 1];
      return;
    }
    const e0 = inedges[i2];
    if (e0 === -1) return;
    let e2 = e0, p0 = -1;
    do {
      yield p0 = triangles[e2];
      e2 = e2 % 3 === 2 ? e2 - 2 : e2 + 1;
      if (triangles[e2] !== i2) return;
      e2 = halfedges[e2];
      if (e2 === -1) {
        const p = hull[(_hullIndex[i2] + 1) % hull.length];
        if (p !== p0) yield p;
        return;
      }
    } while (e2 !== e0);
  }
  find(x2, y2, i2 = 0) {
    if ((x2 = +x2, x2 !== x2) || (y2 = +y2, y2 !== y2)) return -1;
    const i0 = i2;
    let c;
    while ((c = this._step(i2, x2, y2)) >= 0 && c !== i2 && c !== i0) i2 = c;
    return c;
  }
  _step(i2, x2, y2) {
    const { inedges, hull, _hullIndex, halfedges, triangles, points } = this;
    if (inedges[i2] === -1 || !points.length) return (i2 + 1) % (points.length >> 1);
    let c = i2;
    let dc = pow(x2 - points[i2 * 2], 2) + pow(y2 - points[i2 * 2 + 1], 2);
    const e0 = inedges[i2];
    let e2 = e0;
    do {
      let t2 = triangles[e2];
      const dt = pow(x2 - points[t2 * 2], 2) + pow(y2 - points[t2 * 2 + 1], 2);
      if (dt < dc) dc = dt, c = t2;
      e2 = e2 % 3 === 2 ? e2 - 2 : e2 + 1;
      if (triangles[e2] !== i2) break;
      e2 = halfedges[e2];
      if (e2 === -1) {
        e2 = hull[(_hullIndex[i2] + 1) % hull.length];
        if (e2 !== t2) {
          if (pow(x2 - points[e2 * 2], 2) + pow(y2 - points[e2 * 2 + 1], 2) < dc) return e2;
        }
        break;
      }
    } while (e2 !== e0);
    return c;
  }
  render(context) {
    const buffer = context == null ? context = new Path() : void 0;
    const { points, halfedges, triangles } = this;
    for (let i2 = 0, n2 = halfedges.length; i2 < n2; ++i2) {
      const j2 = halfedges[i2];
      if (j2 < i2) continue;
      const ti = triangles[i2] * 2;
      const tj = triangles[j2] * 2;
      context.moveTo(points[ti], points[ti + 1]);
      context.lineTo(points[tj], points[tj + 1]);
    }
    this.renderHull(context);
    return buffer && buffer.value();
  }
  renderPoints(context, r2) {
    if (r2 === void 0 && (!context || typeof context.moveTo !== "function")) r2 = context, context = null;
    r2 = r2 == void 0 ? 2 : +r2;
    const buffer = context == null ? context = new Path() : void 0;
    const { points } = this;
    for (let i2 = 0, n2 = points.length; i2 < n2; i2 += 2) {
      const x2 = points[i2], y2 = points[i2 + 1];
      context.moveTo(x2 + r2, y2);
      context.arc(x2, y2, r2, 0, tau);
    }
    return buffer && buffer.value();
  }
  renderHull(context) {
    const buffer = context == null ? context = new Path() : void 0;
    const { hull, points } = this;
    const h = hull[0] * 2, n2 = hull.length;
    context.moveTo(points[h], points[h + 1]);
    for (let i2 = 1; i2 < n2; ++i2) {
      const h2 = 2 * hull[i2];
      context.lineTo(points[h2], points[h2 + 1]);
    }
    context.closePath();
    return buffer && buffer.value();
  }
  hullPolygon() {
    const polygon = new Polygon();
    this.renderHull(polygon);
    return polygon.value();
  }
  renderTriangle(i2, context) {
    const buffer = context == null ? context = new Path() : void 0;
    const { points, triangles } = this;
    const t0 = triangles[i2 *= 3] * 2;
    const t1 = triangles[i2 + 1] * 2;
    const t2 = triangles[i2 + 2] * 2;
    context.moveTo(points[t0], points[t0 + 1]);
    context.lineTo(points[t1], points[t1 + 1]);
    context.lineTo(points[t2], points[t2 + 1]);
    context.closePath();
    return buffer && buffer.value();
  }
  *trianglePolygons() {
    const { triangles } = this;
    for (let i2 = 0, n2 = triangles.length / 3; i2 < n2; ++i2) {
      yield this.trianglePolygon(i2);
    }
  }
  trianglePolygon(i2) {
    const polygon = new Polygon();
    this.renderTriangle(i2, polygon);
    return polygon.value();
  }
};
function flatArray(points, fx, fy, that) {
  const n2 = points.length;
  const array = new Float64Array(n2 * 2);
  for (let i2 = 0; i2 < n2; ++i2) {
    const p = points[i2];
    array[i2 * 2] = fx.call(that, p, i2, points);
    array[i2 * 2 + 1] = fy.call(that, p, i2, points);
  }
  return array;
}
function* flatIterable(points, fx, fy, that) {
  let i2 = 0;
  for (const p of points) {
    yield fx.call(that, p, i2, points);
    yield fy.call(that, p, i2, points);
    ++i2;
  }
}

// node_modules/@nivo/voronoi/dist/nivo-voronoi.mjs
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
function C() {
  return C = Object.assign ? Object.assign.bind() : function(n2) {
    for (var o2 = 1; o2 < arguments.length; o2++) {
      var e2 = arguments[o2];
      for (var i2 in e2) ({}).hasOwnProperty.call(e2, i2) && (n2[i2] = e2[i2]);
    }
    return n2;
  }, C.apply(null, arguments);
}
function y(n2, o2) {
  if (null == n2) return {};
  var e2 = {};
  for (var i2 in n2) if ({}.hasOwnProperty.call(n2, i2)) {
    if (-1 !== o2.indexOf(i2)) continue;
    e2[i2] = n2[i2];
  }
  return e2;
}
var w = { xDomain: [0, 1], yDomain: [0, 1], layers: ["links", "cells", "points", "bounds"], enableLinks: false, linkLineWidth: 1, linkLineColor: "#bbbbbb", enableCells: true, cellLineWidth: 2, cellLineColor: "#000000", enablePoints: true, pointSize: 4, pointColor: "#666666", role: "img" };
var D2 = function(n2) {
  return [n2.x, n2.y];
};
var L = un;
var T = "cursor";
var P = "top";
var R = function(n2) {
  var o2 = n2.points, e2 = n2.getNodePosition, i2 = void 0 === e2 ? D2 : e2, t2 = n2.margin, l2 = void 0 === t2 ? L : t2;
  return o2.map(function(n3) {
    var o3 = i2(n3), e3 = o3[0], t3 = o3[1];
    return [e3 + l2.left, t3 + l2.top];
  });
};
var W = function(n2) {
  var o2 = n2.points, e2 = n2.width, i2 = n2.height, t2 = n2.margin, l2 = void 0 === t2 ? L : t2, r2 = n2.debug, u5 = Delaunay.from(o2), a = r2 ? u5.voronoi([0, 0, l2.left + e2 + l2.right, l2.top + i2 + l2.bottom]) : void 0;
  return { points: o2, delaunay: u5, voronoi: a };
};
var E = function(o2) {
  var e2 = o2.points, i2 = o2.getNodePosition, t2 = void 0 === i2 ? D2 : i2, l2 = o2.width, r2 = o2.height, u5 = o2.margin, a = void 0 === u5 ? L : u5, d = o2.debug;
  return (0, import_react.useMemo)(function() {
    return W({ points: R({ points: e2, margin: a, getNodePosition: t2 }), width: l2, height: r2, margin: a, debug: d });
  }, [t2, e2, l2, r2, a, d]);
};
var x = function(o2) {
  var e2 = o2.data, i2 = o2.width, t2 = o2.height, l2 = o2.xDomain, r2 = o2.yDomain, u5 = (0, import_react.useMemo)(function() {
    return linear().domain(l2).range([0, i2]);
  }, [l2, i2]), a = (0, import_react.useMemo)(function() {
    return linear().domain(r2).range([0, t2]);
  }, [r2, t2]), d = (0, import_react.useMemo)(function() {
    return e2.map(function(n2) {
      return { x: u5(n2.x), y: a(n2.y), data: n2 };
    });
  }, [e2, u5, a]);
  return (0, import_react.useMemo)(function() {
    var n2 = Delaunay.from(d.map(function(n3) {
      return [n3.x, n3.y];
    })), o3 = n2.voronoi([0, 0, i2, t2]);
    return { points: d, delaunay: n2, voronoi: o3 };
  }, [d, i2, t2]);
};
var S = function(o2) {
  var e2 = o2.points, i2 = o2.delaunay, t2 = o2.voronoi;
  return (0, import_react.useMemo)(function() {
    return { points: e2, delaunay: i2, voronoi: t2 };
  }, [e2, i2, t2]);
};
var U = function(l2) {
  var r2 = l2.elementRef, u5 = l2.nodes, a = l2.getNodePosition, h = void 0 === a ? D2 : a, c = l2.delaunay, v2 = l2.setCurrent, f = l2.margin, p = void 0 === f ? L : f, g = l2.detectionRadius, m2 = void 0 === g ? 1 / 0 : g, b2 = l2.isInteractive, k2 = void 0 === b2 || b2, C3 = l2.onMouseEnter, y2 = l2.onMouseMove, w2 = l2.onMouseLeave, R2 = l2.onMouseDown, W2 = l2.onMouseUp, E2 = l2.onClick, x2 = l2.onDoubleClick, S2 = l2.onTouchStart, U2 = l2.onTouchMove, z2 = l2.onTouchEnd, A2 = l2.enableTouchCrosshair, N2 = void 0 !== A2 && A2, H2 = l2.tooltip, O2 = l2.tooltipPosition, I2 = void 0 === O2 ? T : O2, j2 = l2.tooltipAnchor, F2 = void 0 === j2 ? P : j2, B2 = (0, import_react.useState)(null), q2 = B2[0], G = B2[1], J = (0, import_react.useRef)(null);
  (0, import_react.useEffect)(function() {
    J.current = q2;
  }, [J, q2]);
  var K = (0, import_react.useCallback)(function(n2) {
    if (!r2.current || 0 === u5.length) return null;
    var o2 = kn(r2.current, n2), e2 = o2[0], i2 = o2[1], t2 = c.find(e2, i2), l3 = void 0 !== t2 ? u5[t2] : null;
    if (l3 && m2 !== 1 / 0) {
      var a2 = h(l3), v3 = a2[0], f2 = a2[1];
      yn(e2, i2, v3 + p.left, f2 + p.top) > m2 && (t2 = null, l3 = null);
    }
    return null === t2 || null === l3 ? null : [t2, l3];
  }, [r2, c, u5, h, p, m2]), Q = z(), V = Q.showTooltipAt, X = Q.showTooltipFromEvent, Y = Q.hideTooltip, Z = (0, import_react.useMemo)(function() {
    if (H2) return "cursor" === I2 ? function(n2, o2) {
      X(H2(n2), o2, F2);
    } : function(n2) {
      var o2 = h(n2), e2 = o2[0], i2 = o2[1];
      V(H2(n2), [e2 + p.left, i2 + p.top], F2);
    };
  }, [V, X, H2, I2, F2, h, p]), $ = (0, import_react.useCallback)(function(n2) {
    var o2 = K(n2);
    if (G(o2), null == v2 || v2(o2 ? o2[1] : null), o2) {
      var e2 = o2[1];
      null == Z || Z(e2, n2), null == C3 || C3(o2[1], n2);
    }
  }, [K, G, v2, Z, C3]), _ = (0, import_react.useCallback)(function(n2) {
    var o2 = K(n2);
    if (G(o2), o2) {
      var e2 = o2[0], i2 = o2[1];
      if (null == v2 || v2(i2), null == Z || Z(i2, n2), J.current) {
        var t2 = J.current, l3 = t2[0], r3 = t2[1];
        e2 !== l3 ? null == w2 || w2(r3, n2) : null == y2 || y2(i2, n2);
      } else null == C3 || C3(i2, n2);
    } else null == v2 || v2(null), null == Y || Y(), J.current && (null == w2 || w2(J.current[1], n2));
  }, [K, G, v2, J, C3, y2, w2, Z, Y]), nn = (0, import_react.useCallback)(function(n2) {
    G(null), null == v2 || v2(null), Y(), w2 && J.current && w2(J.current[1], n2);
  }, [G, v2, J, Y, w2]), on = (0, import_react.useCallback)(function(n2) {
    var o2 = K(n2);
    G(o2), o2 && (null == R2 || R2(o2[1], n2));
  }, [K, G, R2]), en = (0, import_react.useCallback)(function(n2) {
    var o2 = K(n2);
    G(o2), o2 && (null == W2 || W2(o2[1], n2));
  }, [K, G, W2]), tn = (0, import_react.useCallback)(function(n2) {
    var o2 = K(n2);
    G(o2), o2 && (null == E2 || E2(o2[1], n2));
  }, [K, G, E2]), ln = (0, import_react.useCallback)(function(n2) {
    var o2 = K(n2);
    G(o2), o2 && (null == x2 || x2(o2[1], n2));
  }, [K, G, x2]), rn = (0, import_react.useCallback)(function(n2) {
    var o2 = K(n2);
    N2 && (G(o2), null == v2 || v2(o2 ? o2[1] : null)), o2 && (null == S2 || S2(o2[1], n2));
  }, [K, G, v2, N2, S2]), un2 = (0, import_react.useCallback)(function(n2) {
    var o2 = K(n2);
    N2 && (G(o2), null == v2 || v2(o2 ? o2[1] : null)), o2 && (null == U2 || U2(o2[1], n2));
  }, [K, G, v2, N2, U2]), an = (0, import_react.useCallback)(function(n2) {
    N2 && (G(null), null == v2 || v2(null)), z2 && J.current && z2(J.current[1], n2);
  }, [N2, G, v2, z2, J]);
  return { current: q2, handleMouseEnter: k2 ? $ : void 0, handleMouseMove: k2 ? _ : void 0, handleMouseLeave: k2 ? nn : void 0, handleMouseDown: k2 ? on : void 0, handleMouseUp: k2 ? en : void 0, handleClick: k2 ? tn : void 0, handleDoubleClick: k2 ? ln : void 0, handleTouchStart: k2 ? rn : void 0, handleTouchMove: k2 ? un2 : void 0, handleTouchEnd: k2 ? an : void 0 };
};
var A = ["theme"];
var N = function(n2) {
  var o2 = n2.data, e2 = n2.width, i2 = n2.height, t2 = n2.margin, l2 = n2.layers, a = void 0 === l2 ? w.layers : l2, d = n2.xDomain, s = void 0 === d ? w.xDomain : d, h = n2.yDomain, f = void 0 === h ? w.yDomain : h, p = n2.enableLinks, g = void 0 === p ? w.enableLinks : p, M = n2.linkLineWidth, b2 = void 0 === M ? w.linkLineWidth : M, k2 = n2.linkLineColor, C3 = void 0 === k2 ? w.linkLineColor : k2, y2 = n2.enableCells, D3 = void 0 === y2 ? w.enableCells : y2, L2 = n2.cellLineWidth, T2 = void 0 === L2 ? w.cellLineWidth : L2, P2 = n2.cellLineColor, R2 = void 0 === P2 ? w.cellLineColor : P2, W2 = n2.enablePoints, E2 = void 0 === W2 ? w.enableCells : W2, U2 = n2.pointSize, z2 = void 0 === U2 ? w.pointSize : U2, A2 = n2.pointColor, N2 = void 0 === A2 ? w.pointColor : A2, H2 = n2.role, O2 = void 0 === H2 ? w.role : H2, I2 = n2.forwardedRef, j2 = cn(e2, i2, t2), F2 = j2.outerWidth, B2 = j2.outerHeight, q2 = j2.margin, G = j2.innerWidth, J = j2.innerHeight, K = x({ data: o2, width: G, height: J, xDomain: s, yDomain: f }), Q = K.points, V = K.delaunay, X = K.voronoi, Y = { links: null, cells: null, points: null, bounds: null };
  g && a.includes("links") && (Y.links = (0, import_jsx_runtime.jsx)("path", { stroke: C3, strokeWidth: b2, fill: "none", d: V.render() }, "links")), D3 && a.includes("cells") && (Y.cells = (0, import_jsx_runtime.jsx)("path", { d: X.render(), fill: "none", stroke: R2, strokeWidth: T2 }, "cells")), E2 && a.includes("points") && (Y.points = (0, import_jsx_runtime.jsx)("path", { stroke: "none", fill: N2, d: V.renderPoints(void 0, z2 / 2) }, "points")), a.includes("bounds") && (Y.bounds = (0, import_jsx_runtime.jsx)("path", { fill: "none", stroke: R2, strokeWidth: T2, d: X.renderBounds() }, "bounds"));
  var Z = S({ points: Q, delaunay: V, voronoi: X });
  return (0, import_jsx_runtime.jsx)(Rt, { width: F2, height: B2, margin: q2, role: O2, ref: I2, children: a.map(function(n3, o3) {
    return void 0 !== Y[n3] ? Y[n3] : "function" == typeof n3 ? (0, import_jsx_runtime.jsx)(import_react.Fragment, { children: (0, import_react.createElement)(n3, Z) }, o3) : null;
  }) });
};
var H = (0, import_react.forwardRef)(function(n2, o2) {
  var e2 = n2.theme, i2 = y(n2, A);
  return (0, import_jsx_runtime.jsx)(Fr, { isInteractive: false, animate: false, theme: e2, children: (0, import_jsx_runtime.jsx)(N, C({}, i2, { forwardedRef: o2 })) });
});
var O = ["defaultWidth", "defaultHeight", "onResize", "debounceResize"];
var I = (0, import_react.forwardRef)(function(n2, o2) {
  var e2 = n2.defaultWidth, i2 = n2.defaultHeight, t2 = n2.onResize, l2 = n2.debounceResize, r2 = y(n2, O);
  return (0, import_jsx_runtime.jsx)($r, { defaultWidth: e2, defaultHeight: i2, onResize: t2, debounceResize: l2, children: function(n3) {
    var e3 = n3.width, i3 = n3.height;
    return (0, import_jsx_runtime.jsx)(H, C({}, r2, { width: e3, height: i3, ref: o2 }));
  } });
});
var j = function(o2) {
  var i2 = o2.nodes, t2 = o2.width, l2 = o2.height, r2 = o2.margin, u5 = void 0 === r2 ? L : r2, a = o2.getNodePosition, d = o2.setCurrent, s = o2.onMouseEnter, h = o2.onMouseMove, c = o2.onMouseLeave, v2 = o2.onMouseDown, f = o2.onMouseUp, p = o2.onClick, g = o2.onDoubleClick, M = o2.onTouchStart, C3 = o2.onTouchMove, y2 = o2.onTouchEnd, w2 = o2.enableTouchCrosshair, D3 = void 0 !== w2 && w2, R2 = o2.detectionRadius, W2 = void 0 === R2 ? 1 / 0 : R2, x2 = o2.tooltip, S2 = o2.tooltipPosition, z2 = void 0 === S2 ? T : S2, A2 = o2.tooltipAnchor, N2 = void 0 === A2 ? P : A2, H2 = o2.debug, O2 = (0, import_react.useRef)(null), I2 = E({ points: i2, getNodePosition: a, width: t2, height: l2, margin: u5, debug: H2 }), j2 = I2.delaunay, F2 = I2.voronoi, B2 = U({ elementRef: O2, nodes: i2, delaunay: j2, margin: u5, detectionRadius: W2, setCurrent: d, onMouseEnter: s, onMouseMove: h, onMouseLeave: c, onMouseDown: v2, onMouseUp: f, onClick: p, onDoubleClick: g, onTouchStart: M, onTouchMove: C3, onTouchEnd: y2, enableTouchCrosshair: D3, tooltip: x2, tooltipPosition: z2, tooltipAnchor: N2 }), q2 = B2.current, G = B2.handleMouseEnter, J = B2.handleMouseMove, K = B2.handleMouseLeave, Q = B2.handleMouseDown, V = B2.handleMouseUp, X = B2.handleClick, Y = B2.handleDoubleClick, Z = B2.handleTouchStart, $ = B2.handleTouchMove, _ = B2.handleTouchEnd, nn = (0, import_react.useMemo)(function() {
    if (H2 && F2) return F2.render();
  }, [H2, F2]);
  return (0, import_jsx_runtime.jsxs)("g", { ref: O2, transform: "translate(" + -u5.left + "," + -u5.top + ")", children: [H2 && F2 && (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("path", { d: nn, stroke: "red", strokeWidth: 1, opacity: 0.75 }), W2 < 1 / 0 && (0, import_jsx_runtime.jsx)("path", { stroke: "red", strokeWidth: 0.35, fill: "none", d: j2.renderPoints(void 0, W2) }), q2 && (0, import_jsx_runtime.jsx)("path", { fill: "pink", opacity: 0.35, d: F2.renderCell(q2[0]) })] }), (0, import_jsx_runtime.jsx)("rect", { "data-ref": "mesh-interceptor", width: u5.left + t2 + u5.right, height: u5.top + l2 + u5.bottom, fill: "red", opacity: 0, style: { cursor: "auto" }, onMouseEnter: G, onMouseMove: J, onMouseLeave: K, onMouseDown: Q, onMouseUp: V, onTouchStart: Z, onTouchMove: $, onTouchEnd: _, onClick: X, onDoubleClick: Y })] });
};
var F = function(n2, o2) {
  n2.save(), n2.globalAlpha = 0.75, n2.beginPath(), o2.render(n2), n2.strokeStyle = "red", n2.lineWidth = 1, n2.stroke(), n2.restore();
};
var q = function(n2, o2, e2) {
  n2.save(), n2.globalAlpha = 0.35, n2.beginPath(), o2.renderCell(e2, n2), n2.fillStyle = "pink", n2.fill(), n2.restore();
};

export {
  E,
  j,
  F,
  q
};
//# sourceMappingURL=chunk-DP6D7EXL.js.map
